#### 线程

##### Thread类
- Thread类实现了Runnable，提供了很多扩展功能
- start方法只是启动线程，该方法是异步非阻塞的，是多线程的核心
- 继承Thread时，重写run方法

```
public class Test2 {

    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        new Thread(t1, "线程1").start();
        new Thread(t1, "线程2").start();
    }
    
    public static class MyThread extends Thread {
        private int total = 10;
    
        @Override
        public void run() {
            for (int i = 0; i < 10; i++) {
                synchronized (this) {
                    if (total > 0) {
                        try {
                            Thread.sleep(100);
                            System.out.println(Thread.currentThread().getName() + "卖票---->" + (this.total--));
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        }
    }
}
```

##### Runnable和Callable区别
1. 实现Callable接口的任务线程能返回执行结果；而实现Runnable接口的任务线程不能返回结果；（需要调用FutureTask.get()，此方法会阻塞主线程直到获取结果）
1. Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛；
1. Callabe本质就是run，只不过提供了返回值。

##### 阻塞
- sleep():并不会释放锁；该方法让当前正在执行的线程在指定时间内暂停执行，进入阻塞状态，同优先级或更高优先级的线程获得执行权。
- wait():在synchronize中（同步代码块或者同步方法），当对象调用该方法，当前正在执行的线程暂停执行，并扔入对象的等待池内，只有在调用notify或notifyall后，该线程或所有线程进入对象的锁池中。
- yield():并不会释放锁；该方法让当前正在执行的线程重新回到可执行状态。
- join()：当前线程等待调用了join()方法的线程全部执行完后才开始执行


---

#### 线程池：

##### 类图
![image](images/9485)
- Executor——执行接口，定义了execute方法
- ExecutorService——扩展了执行接口，如submit
- AbstractExecutorService实现了ExecutorService，提供了submit的默认实现(执行execute并返回Future)，原理是利用FutureTask
- FutureTask实现RunnableFuture，RunnableFuture继承Runnable和Future<V>，FutureTask提供run、get、cancel等方法。FutureTask.run是对submit方法传入的runnable或callable进行代理并将返回结果写入FutureTask的属性中。
- ThreadPoolExecutor和ForkJoinPool继承自AbstractExecutorService，都重写了execute方法



##### 多线程异步处理业务中使用CountDownLatch计数器同步化：
new CountDownLatch(N)初始化子线程数；await()挂起当前线程；需要异步处理的业务最后countDown()，子线程完成后减1

##### 线程池的原理：
先看核心线程数corePoolSize（存活时间无限），再看任务队列，再看最大线程数maximumPoolSize（非核心线程存活时间为keepAliveTime）



> 在《阿里巴巴Java开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。
> 
> 使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。
> 
> 另外《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险
> 
> Executors返回线程池对象的弊端如下：
> - FixedThreadPool 和 SingleThreadExecutor ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致OOM。
> - CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。

---

### 线程安全

线程安全：多线程访问一个资源（对象）时，通过同步锁机制保护资源，防止数据不一致或数据污染

线程不安全：当多线程访问同一个资源（对象）时，没有进行同步控制的锁机制，就是不安全

java线程安全的编码：通过线程同步控制来实现的，例如静态全局变量使用Vector、Currenthashmap、StringBuffer等线程安全的数据结构（防止多线程不安全）;实例变量不影响线程安全（每个线程操作不同的实例）

###### 注意：一般多线程安全不包括数据库，因为数据库本身有事务隔离的并发控制

---

## ThreadLocal
**ThreadLocal**底层使用**Thread**类的属性**ThreadLocalMap**来实现屏蔽共享资源的。

ThreadLocal-set方法具体实现：

```
public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}
// ThreadLocalMap属于ThreadLocal的内部类，是Thread的成员属性，因此每个线程有各自的ThreadLocalMap内存空间
```
ThreadLocal-get方法具体实现：

```
public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings("unchecked")
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}
```



**ThreadLocalMap**底层结构使用Entry存储、获取、释放

ThreadLocalMap内部结构实现：

```
// 初次使用，Entry默认大小为INITIAL_CAPACITY（16）
ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {
    table = new Entry[INITIAL_CAPACITY];
    int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);
    table[i] = new Entry(firstKey, firstValue);
    size = 1;
    setThreshold(INITIAL_CAPACITY);
}

// Entry的键ThreadLocal为弱引用，保存对象引用为强引用
static class Entry extends WeakReference<ThreadLocal<?>> {
    /** The value associated with this ThreadLocal. */
    Object value;

    Entry(ThreadLocal<?> k, Object v) {
        super(k);
        value = v;
    }
}
```

ThreadLocalMap-getEntry实现
```
private Entry getEntry(ThreadLocal<?> key) {
    int i = key.threadLocalHashCode & (table.length - 1);
    Entry e = table[i];
    if (e != null && e.get() == key)
        return e;
    else
        return getEntryAfterMiss(key, i, e);
}
```

ThreadLocalMap-remove实现
```
/**
 * Remove the entry for key.
 */
private void remove(ThreadLocal<?> key) {
    Entry[] tab = table;
    int len = tab.length;
    int i = key.threadLocalHashCode & (len-1);
    for (Entry e = tab[i];
         e != null;
         e = tab[i = nextIndex(i, len)]) {
        if (e.get() == key) {
            e.clear();
            expungeStaleEntry(i);
            return;
        }
    }
}
```

清理强引用实现

```
private Entry getEntryAfterMiss(ThreadLocal<?> key, int i, Entry e) {
    Entry[] tab = table;
    int len = tab.length;

    while (e != null) {
        ThreadLocal<?> k = e.get();
        if (k == key)
            return e;
        if (k == null)
            expungeStaleEntry(i);
        else
            i = nextIndex(i, len);
        e = tab[i];
    }
    return null;
}
```

##### 最佳实践：
- remove()、set()方法中，真正用来回收value的是expungeStaleEntry()。
- ThreadLocal使用了弱引用维护key，在getEntry()方法中检查key是否被回收进而回收value。但是如果threadLocal一直被get()访问，清理动作就不会执行，所以还是主动调用remove()最好。
- ThreadLocalMap的每个Entry的key都是弱引用，当这个引用不被其他对象使用时，则ThreadLocal对象会被自动回收。

---
### 线程工作空间

1.所有的变量都存储在主内存中，对于所有线程都是共享的。

2.每条线程都有自己的工作内存（java使用ThreadLocalMap实现），工作内存中保存的是主存中某些变量的拷贝，线程对变量的所有操作都必须在工作内存中进行，完成操作以后才会同步给主内存

3.线程之间无法直接访问对方的工作内存中的变量，线程间变量的传递均需要通过主内存来完成。

###### 注意：至于i++是否线程安全，肯定不是安全的。线程对变量的操作都在各自的栈内存中进行，首先是不可见的。即使用volatil将变量可见，所有线程直接从主内存中读写，也会引起并发问题，所以还得对i++代码块加同步方法锁

---

### 死锁产生条件

1. 互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。
1. 请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。
1. 不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。
1. 环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。


###### 案例

```
public static void main(String[] args) {
		//实现死锁--互斥
		Thread lo1 = new Thread(new Runnable() {
			@Override
			public void run() {
				synchronized ("o1") {
					System.out.println("lo1获得o1锁");
					synchronized ("o2") {
						System.out.println("lo1获得o2锁");
					}
				}
			}
		});

		Thread lo2 = new Thread(new Runnable() {
			@Override
			public void run() {
				synchronized ("o2") {
					System.out.println("lo2获得o2锁");
					synchronized ("o1") {
						System.out.println("lo2获得o1锁");
					}
				}
			}
		});
		lo1.start();
		lo2.start();
	}
```

