### 1. 通过RESTFUL框架远程调用接口
### 2. 通过RPC框架远程调用接口

##### http调用
1.httpclient

```
    @Override
    public String getOrderDetails(AdditionalTicketServiceDisplayReq req) {
        String url = ecsUrl+"/ecsinterface/ecp/order/service/ms/additionalTicketService/display";
        PostMethod post = new PostMethod(url);
        String message = null;
        try {
            post.setRequestHeader("Content-Type", TYPE);
            post.setRequestHeader("Accept", "application/xml");
            RequestEntity entity = new StringRequestEntity("{\"additionalTicketServiceDisplayReq\":"
                    + JSONObject.toJSONString(req) + "}", TYPE, CHARSET);
            post.setRequestEntity(entity);
            message = getResponseMessage(post);
        } catch (Exception e) {
            LogUtil.error(LOGGER, "调用ECS接口获取订单详情出错：" + post.getPath(), e);
        }

        if(StringUtils.isBlank(message)){
            LOGGER.error("ECS订单详情返回为空,入参为:{}", req);
            return null;
        }else{
            return message;
        }
    }

```

工具类

```
package com.csair.job.util;

import java.io.IOException;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;

import org.apache.commons.httpclient.HttpClient;
import org.apache.commons.httpclient.HttpException;
import org.apache.commons.httpclient.HttpStatus;
import org.apache.commons.httpclient.NameValuePair;
import org.apache.commons.httpclient.methods.PostMethod;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class HttpClientUtils {
	private static Logger LOGGER = LoggerFactory.getLogger(HttpClientUtils.class);

	public static String post(String url, Map<String, String> param ,int timeOut) throws HttpException, IOException {
		HttpClient httpClient = new HttpClient();
		PostMethod p = new PostMethod(url);
		Iterator<Entry<String, String>> iter = param.entrySet().iterator();
		LOGGER.info("HttpClientUtils-posy-request:{}", param.toString());
		while (iter.hasNext()) {
			Entry<String, String> entry = iter.next();
			String key = entry.getKey();
			String value = entry.getValue();
			p.addParameter(new NameValuePair(key, value));
		}
		httpClient.getParams().setContentCharset("UTF-8");
		httpClient.getHttpConnectionManager().getParams().setConnectionTimeout(timeOut);
		httpClient.getHttpConnectionManager().getParams().setSoTimeout(timeOut);
		httpClient.executeMethod(p);
		if (p.getStatusCode() == HttpStatus.SC_OK) {
			String message = p.getResponseBodyAsString();
			LOGGER.info("HttpClientUtils-posy-result:{}", message);
			return message;
		} else {
			LOGGER.info("HttpClientUtils-posy:接口调用失败=======");
			return null;
		}
	}
}

```

2.Feign调用

```
package com.csair.inquire.webServer.ita;

import com.csair.common.BaseWebApi;
import com.csair.configuration.TimoutTwentySecondFeignConfig;

import org.springframework.cloud.netflix.feign.FeignClient;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;


@FeignClient(name = "ita", url = "${csair.ita.path}",configuration = TimoutTwentySecondFeignConfig.class)
public interface ItaClient  extends BaseWebApi{
	
	/**
	 * ItaQpxc接口统一调用方法
	 * @param requestXML 此入参为Ita接口中Search对象的xml形式
	 * @return 此返参为Ita接口中Result对象的xml形式
	 */
	@RequestMapping(value = "${csair.ita.qpxcSearch}", method = RequestMethod.POST, consumes="text/xml", headers = {"X-Sales-Channel=${csair.ita.xSalesChannel}"})
	public String serchForItaQpxc(String requestXML,@RequestHeader("subChannel")String subChannel);

}


```

##### RPC远程调用（待补充）

注册中心挂了可以继续通信吗？
可以，因为刚开始初始化的时候，消费者会将提供者的地址等信息拉取到本地缓存，所以注册中心挂了可以继续通信