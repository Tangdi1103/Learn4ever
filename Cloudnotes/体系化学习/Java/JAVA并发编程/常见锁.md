[toc]

### 1. synchronized

java内建的同步机制，**代码实现在JVM的代码中**

#### java 6之前

通过一对monitorenter/monitorexit指令实现同步机制，monitor底层调用的是==操作系统内部的互斥锁来实现==，由于==用户态和内核态的转换==，是一个重量级锁，并且只有**两种状态：无锁、重量级锁**



##### 特性

![image-20220307173535198](images/image-20220307173535198.png)



##### Synchronized底层结构

![image-20220220220756456](images/image-20220220220756456.png)

##### 底层实现原理

![image-20220220221323440](images/image-20220220221323440.png)

![image-20220307173723222](images/image-20220307173723222.png)



#### java 6之后

优化内容

![image-20220220224224158](images/image-20220220224224158.png)

锁膨胀

![image-20220220224754743](images/image-20220220224754743.png)

偏向锁

![image-20220220224947104](images/image-20220220224947104.png)

轻量锁和重量锁

![image-20220220225331695](images/image-20220220225331695.png)

锁消除

![image-20220220225813136](images/image-20220220225813136.png)

锁粗化

![image-20220220230151822](images/image-20220220230151822.png)

自旋锁和自适应自旋锁

![image-20220220231105300](images/image-20220220231105300.png)



通过三种不同的monitor指令实现同步机制，也就是说三种不同的锁实现：==偏斜锁(BiasedLocking)、轻量锁、重量锁==。

Synchronized==默认使用偏斜锁实现==，JVM 会利用 CAS 操作（compare and swap），==在对象头上的 Mark Word 部分设置线程 ID==，以表示这个对象==偏向于当前线程==，所以并不涉及真正的互斥锁，从而大大降低了无竞争时的开销，*当出现竞争的情况，撤销（revoke）偏斜锁，并利用CAS 操作 Mark Word 来试图获取锁并升级至轻量锁，失败则升级至重量锁*（==锁膨胀==）

**锁的升/降级：**Synchronized优化锁的机制，JVM检测不同的竞争状况，切换合适的锁实现

**性能分析：**==撤销偏斜锁是一个比较重操作==，只有当存在较多无竞争的 synchronized 块时，才能明显改善开销。==若存在大量竞争的 synchronized 块，则应该通过JVM关闭偏斜锁==。偏斜锁还会==延缓 JIT 预热的进程==，所以很多性能测试中会显式地==关闭偏斜锁== ：**`-XX:-UseBiasedLocking`**



### 2. ReentrantLock（再入锁）

定义：当一个线程试图获取一个它已经获取的锁时，这个获取动作就自动成功，这是对锁获取粒度的一个概念

##### java 5才出现

通过对象实现锁的操作，并提供了很多Synchronized无法实现的细节

- **公平性fairness：**减少线程饥饿的现象 **`ReentrantLock fairLock = new ReentrantLock(true);`**

- **条件变量Condition：**设置独立的队列，提供针对性的阻塞和唤醒的功能await/signal ，对应wait/notify

  **`Condition notEmpty = lock.newCondition();`**

- 带超时的获取锁

![image-20220307174533303](images/image-20220307174533303.png)



### 3. ReadWriteLock（读写锁）

ReentrantReadWriteLock 是Java标准类库提供的再入锁版本实现的读写锁，对应行为的语义与ReentrantLock相似。

读操作之间不需要互斥，可以并发执行。而写操作则会影响一致性，所以需要互斥逻辑

```java
public class RWSample {
    private final Map<String, String> m = new TreeMap<>();
	private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
	private final Lock r = rwl.readLock();
	private final Lock w = rwl.writeLock();
    
	public String get(String key) {
    	r.lock();
    	System.out.println(" 读锁锁定！");
    	try {
        	return m.get(key);
    	} finally {
        	r.unlock();
    	}
	}
 
	public String put(String key, String entry) {
    	w.lock();
		System.out.println(" 写锁锁定！");
        try {
            return m.put(key, entry);
        } finally {
            w.unlock();
        }
    }
	// …
}
```

==如果读锁试图锁定时==，==写锁==是被某个线程==持有==，读锁将无法获得，而只好==等待对方操作结束==，这样就可以自动保证不会读取到有争议的数据。

==读写锁==看起来比 synchronized 的粒度似乎细一些，但在实际应用中，其==表现也并不尽如人意==，主要还是因为==相对比较大的开销==。



### 4. StampedLock 

优化了读模式，基于大多数情况下读操作并不会和写操作冲突，其逻辑是==先试着读==，然后通过 validate 方法==确认是否进入了写模式==，如果没有进入，就成功避免了开销；如果==进入==，==则尝试获取读锁==

```java
public class StampedSample {
	private final StampedLock sl = new StampedLock();
 
	void mutate() {
    	long stamp = sl.writeLock();
    	try {
        	write();//伪代码
    	} finally {
        	sl.unlockWrite(stamp);
    	}
	}
 
	Data access() {
    	long stamp = sl.tryOptimisticRead();
    	Data data = read();//伪代码
    	if (!sl.validate(stamp)) {
        	stamp = sl.readLock();
        	try {
            	data = read();//伪代码
        	} finally {
            	sl.unlockRead(stamp);
        	}
    	}
    	return data;
	}
	// …
}
```





### 3. 性能对比

- 无竞争或者低竞争时，java 6之后的Sychronized更优

- 高竞争时，ReentranLock更优
