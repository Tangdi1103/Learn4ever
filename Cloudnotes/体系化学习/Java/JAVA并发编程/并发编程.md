[toc]

### 1. 多线程基础

**线程：**CPU任务调度的最小单位，获得CPU派发的时间片，则开始执行任务。当时间分片被派发给别的线程时，通过程序计数器（PC寄存器）来记录执行的字节码行号。

**注意：**程序在**多线程（或多进程）环境下同时 执行**，同时进行并不是完全指进程或线程在不同的物理 CPU 上独立运行，更多情况下，**是在一个物理 CPU 上交替执行多个线程或进程**。并发既可在线程中，也可在进程中。

**CPU密集型任务：**需要大量CPU算力的任务，本身耗时短，所以不适合创建大量线程（大量线程上下文切换耗时，得不偿失）

**IO密集型任务：**需要大量磁盘IO的任务，本身阻塞时间长，所以适合创建大量线程执行任务（大量线程上下文切换耗时总比长时间IO阻塞好）



#### 1.1 并发编程三大核心基础理论

原子性、可见性、有序性

##### 原子性

定义：一个或者多个操作要么全部成功要么全部失败，并且不能被其他线程干扰或打断

如下所示，结果并不是10000，而是9688。

![image-20220222221329116](images/image-20220222221329116.png)

count++ 的执行实际上不是原子性的，而会被拆分成以下三个步骤执行（这样的步骤不是虚拟的，而是真实情况就是这么执行的）

1. 从主内存中读取 count 的值
2. 计算 +1 的结果
3. 将 +1 的结果赋值给 count变量

如此，便导致线程A还未完成第三步，CPU就切换到线程B执行任务，导致线程B读取到了线程A还未写入的值，最后结果被覆盖

![image-20220222223002203](images/image-20220222223002203.png)

##### 可见性

定义：一个线程对共享变量的修改，另一个线程需要立即可见

如下所示，结果并不是10000，而是9688。

![image-20220222221329116](images/image-20220222221329116.png)

CPU写缓存速度快、内存写速度中、磁盘写速度慢，导致数据同步延时，引发数据不一致的情况。所以CPU引入了本地缓存，如果CPU本地缓存不能及时刷到内存，并发时就会导致可见性的问题

![image-20220222223414186](images/image-20220222223414186.png)





##### 有序性

定义：程序执行的顺序按照代码的先后顺序执行

指令重排序类型如下

- **编译器优化的重排序**：编译器在**不改变单线程程序语义的前提**下，可以**重新安排语句的执行顺序**
- **指令级并行的重排序**：现代处理器采用了**指令级并行技术**（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果**不存在数据依赖性**，处理器可以**改变语句对应机器指令的执行顺序**
- 内存系统的重排序：由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行

如下段双重检查锁的单例模式

![image-20220222224352322](images/image-20220222224352322.png)

看似没有问题，但创建对象并不是一个原子操作，而是被拆分成了以下三个步骤：

1. 分配对象的内存空间
2. 初始化对象
3. 设置instance指向刚分配的内存地址

被重排后，顺序如下：

1. 分配对象的内存空间
2. 设置instance指向刚分配的内存地址
3. 初始化对象

并发时，则导致线程B通过了第一个对象判空的逻辑

![image-20220222225929742](images/image-20220222225929742.png)

#### 1.2 JMM（Java memory model）

在 Java虚拟机规范中试图定义一种Java内存模型来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果





#### 1.3 保证线程安全

线程安全定义：保证多线程环境下共享的、可修改的状态（数据）的正确性





### 2. volatile和synchronized





### 3. 线程池





### 4. JUC





