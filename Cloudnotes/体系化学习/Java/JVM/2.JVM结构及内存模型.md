[toc]

## 一、JVM结构

![image-20220306003723334](images/image-20220306003723334.png)

![image-20220306004504869](images/image-20220306004504869.png)



## 二、JVM内存结构

#### JDK7 的 JVM内存模型

![image-20220306013257610](images/image-20220306013257610.png)
##### 1. 虚拟机栈（JVM Stacks）

**Java虚拟机栈**(Java Virtual Machine Stacks)也是**线程私有**的，即生命周期和线程相同。**Java虚拟机栈和线程同时创建，用于存储栈帧**。**每个方法在执行时都会创建一个栈帧**(Stack Frame)，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。**每一个方法从调用直到执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。**

**虚拟机栈默认大小是1M**，别小看这1M的空间，如果每个用户请求都新建线程的话，1024个用户光线程就占用了1个G的内存，如果系统比较大的话，一下子系统资源就不够用了，最后导致程序崩溃

![image-20220309140948665](images/image-20220309140948665.png)



##### 2. 本地方法栈

![image-20220306005605445](images/image-20220306005605445.png)



##### 3. 程序计数器

![image-20220306012043474](images/image-20220306012043474.png)

![image-20220306011110614](images/image-20220306011110614.png)



##### 4. 堆（Heap）

![image-20220306011248262](images/image-20220306011248262.png)

![image-20220306023926402](images/image-20220306023926402.png)

![image-20220306011732306](images/image-20220306011732306.png)



##### 5. 方法区（Runtime Constant Pool）

方法区是一种JVM规范，其 **JDK1.8之前的实现为堆中的永久代**

![image-20220306011936345](images/image-20220306011936345.png)

![image-20220306012101713](images/image-20220306012101713.png)



##### 6. 总结

![image-20220306012248007](images/image-20220306012248007.png)





#### JDK8 的 JVM内存模型

![image-20220306012945143](images/image-20220306012945143.png)



#### JDK8 对比 JDK7  JVM内存模型的变化

![image-20220306020041429](images/image-20220306020041429.png)

![image-20220306020922567](images/image-20220306020922567.png)



#### 元空间和永久代的区别

![image-20220306021423476](images/image-20220306021423476.png)



#### 为什么要用元空间替代永久代？

![image-20220306021724377](images/image-20220306021724377.png)



#### JDK8 是否就没有方法区了？

![image-20220306021909863](images/image-20220306021909863.png)

