[toc]

## 一、判断对象死亡算法

**垃圾回收（Garbage Collection， 下文简称GC）也称垃圾收集** ，Java程序会**不定时的检查是否有死亡的对象**，**并回收它们占用的内存空间** 

垃圾收集需要完成的三件事情：

- 哪些内存需要回收？
- 什么时候回收？
- 如何回收？

#### 1. 引用计数法（C++用得多）

给**每个创建的对象添加一个引用计数器**，每当此对象**被某个地方引用时，计数值+1，引用失效时-1**，所以当计数值**为0时表示对象已经不能被使用**。引用计数算法大多数情况下是个比较不错的算法，简单直接，也有一些著名的应用案例**但是对于Java虚拟机来说，并不是一个好的选择**，因为它**很难解决对象直接相互循环引用的问题**。

循环引用示例：

![image-20220306223926132](images/image-20220306223926132.png)

以上两个对象他们都互相引用，**除此之外都没有任何对外的引用**， 实际上这两个对象已经不可能再被访问， **但是它们因为互相引用着对方**， 导致它们的**引用计数都不为零**， 引用计数算法也就**无法回收**它们



#### 2. 可达性分析算法

![image-20220306171424412](images/image-20220306171424412.png)

主流的编程程序语言如 **Java、C#等的主流实现中，都是通过可达性分析(Reachability Analysis)来判断对象是否存活的**

此算法的基本思路就是**通过 “GC Roots” 的集合作为起始点**，从**起始点开始向下搜索**到对象的路径。搜索**所经过的路径称为引用链(Reference Chain)**，**当一个对象到任何GC Roots都没有引用链时，则表明对象“不可达”**，即该对象是**不可用的**。

##### 2.1 可以作为GC Root的对象有哪些？

在Java语言中，可作为GC Roots的对象包括下面几种：

- **在虚拟机栈（栈帧中的本地变量表）中引用的对象，即方法中的局部变量**（这意味着方法退出时，对象在栈帧中的强引用将被清空）
- **方法区中静态属性引用的对象**
- **方法区中常量引用的对象**
- 本地方法栈中JNI(Native方法)引用的对象
- **Java虚拟机内部的引用**， 如基本数据类型对应的Class对象， 一些常驻的**异常对象**（比如 NullPointExcepiton、OutOfMemoryError） 等， 还有系统类加载器。
- **所有被同步锁（synchronized关键字） 持有的对象**
- 反映Java虚拟机内部情况的 JMXBean、JVMTI中注册的回调、本地代码缓存等

##### 2.2 三色标记

**可达性分析算法**理论上要求全过程都基于一个能保障**一致性的快照**中才能够进行分析， 这意味着必须**全程冻结用户线程的运行**。GC Roots中的对象数量相比整个堆中的对象数量是很少的，加上oopMap的优化，这部分对象的遍历引起的暂停时间是很短的。但是**从根结点开始往下遍历整个对象图就跟堆内存成正比了**，堆内存越大暂停时间越久。**如果采用并发标记的话，又有以下两个问题，我们先讲解三色标记：**

白色：未被标记的对象（清理时只会回收白色的对象）

灰色：自身被标记，成员变量未被标记（每次都会从灰色处开始访问）

黑色：自身和成员变量都已被标记完成（已经是黑色的对象不在访问）

- **问题1-浮动垃圾：**回收线程在遍历GC Roots引用链时，已经被标记的对象被用户线程抹去了引用，导致成为“浮动垃圾”（需被回收的对象却没有被回收）

  如下图，B和D已经是垃圾了却因为之前的标记而不被回收。这种情况问题不大，下次GC重新标记即可。

  ![image-20220322233336384](images/image-20220322233336384.png)

- **问题2-对象消失：**回收线程在遍历GC Roots引用链时，抹去了白色C的引用（B.d=D变成了B.d=null），并从黑色A创建新引用指向了C（A.d=D），导致回收线程无法访问C而将C当成垃圾（因为黑色代表已经标记完自身和成员变量，只从灰色开始遍历）

  如下图，将正在使用的的对象回收了，这很危险，有以下两种办法：

  ![image-20220322234703136](images/image-20220322234703136.png)

  - **增量更新（Incremental Update）-CMS使用**：A.d=d时，如果A是黑色D是白色，则将黑色A标记为灰色。（有**BUG，比如A.1 = D被标记后还没来得及标记A.2引用，业务线程把A.1引用指向了F。因为回收线程认为A.1引用已经访问过了，所以导致F被回收**）。CMS在并发标记阶段使用的增量更新，所以为了解决这个BUG，才有了第三阶段的重新标记。

    **原理：通过写屏障拦截引用的创建，如果黑色创建引用指向白色，则将黑色改程灰色。**
  
  - **原始快照（Snapshot At The Beginning， SATB）-G1使用**：当**灰色对象要删除指向白色对象的引用关系**时，就将这个**要删除的引用记录下来**，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描 一次





##### 2.3 记忆集

记忆集是一种用于**记录从非收集区域指向收集区域的指针集合**的**抽象**数据结构，避免把整个老年代加进GC Roots扫描范围。

**卡表**就是**记忆集的一种具体实现**，它定义了记忆集的记录精度、与堆内存的映射关系等，其实现为**一个字节数组**。

每个**元素**都**对应**着其标识的**内存区域中一块特定大小的内存块**，这个内存块被称作**“卡页”（Card Page）**。一般来说，卡页大小都是以2的N次幂的字节数，通过上面代码可以看出HotSpot中使用的卡页是2的9次幂，即512字节（地址右移9位，相当于用地址除以512）。那如果卡表标识内存区域的起始地址是0x0000的话，数组CARD_TABLE的第0、1、2号元素，分别对应了地址范围为0x0000～0x01FF、0x0200～0x03FF、0x0400～0x05FF的卡页内存块，如图所示

![image-20220321003841899](images/image-20220321003841899.png)

一个卡页的内存中通常包含不止一个对象，只要**卡页内**有一个（或更多）**对象的字段存在着跨代指针**，那就将**对应卡表的数组元素**的值**标识为1**，称为这个元素**变脏（Dirty）**，没有则标识为0。在垃圾收集发生时，只要**筛选出卡表中变脏的元素**，就能轻易得出哪些卡页内存块中包含跨代指针，然后**将包含跨代指针的卡页加入GC Roots中一并扫描**。







## 二、分代回收理论

#### 1. 定义

根据对象的生命周期将内存划分，然后进行分区管理。 当前商业虚拟机的垃圾收集器， 大多数都遵循了**“分代收集”（Generational Collection）的理论进行设计**， 分代收集名为理论， 实质是一套符合大多数程序运行实际情况的经验法则， 它建立在两个分代假说之上：

- 弱分代假说（Weak Generational Hypothesis） ： 绝大多数对象都是朝生夕灭的。
- 强分代假说（Strong Generational Hypothesis） ： 熬过越多次垃圾收集过程的对象就越难以消亡。

设计原则： 收集器应该**将Java堆划分 出不同的区域**，然后**将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数） 分配到不同的区 域之中存储和回收**

好处：**兼顾了垃圾收集的时间开销**和 对**内存的空间有效利用**



#### 2. GC的类型有哪些

- **部分收集（Partial GC）：**指目标不是完整收集整个Java堆的垃圾收集， 其中又有如下细分
  - 新生代收集（**Minor GC/Young GC**）： 指目标只是**新生代**的垃圾收集。
  - 老年代收集（**Major GC/Old GC**）： 指目标只是**老年代**的垃圾收集，**目前只有CMS收集器会有单独收集老年代的行为**。
  - 混合收集（Mixed GC）： 指目标是收集整个新生代以及部分老年代的垃圾收集。 目前**只有G1收集器会有这种行为**。
- **整堆收集（Full GC）：**收集**整个Java堆 和 方法区**的垃圾收集

在Java堆划分出不同的区域之后， 垃圾收集器才可以每次只回收其中某一个或者某些部分的区域，因此才有了**“Minor GC”、“Major GC”、“Full GC”这样的GC类型的划分**； 

也才能够针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾收集算法——因而发展出了“标记-复制算法”“标记-清除算 法”“标记-整理算法”等针对性的垃圾收集算法。



#### 3. GC的触发条件

##### 3.1 Minor GC触发条件:

- 当 **Eden区满，就会触发Minor GC**，Minor GC会引发STW（stop the world），暂停其他用户的线程，等垃圾回收接收，用户的线程才恢复

##### 3.2 FullGC 触发机制:

- **调用System.gc()**，系统只是建议执行Full GC，但**不是必然执行**

- **老年代空间不足**

- **方法区空间不足（元空间内存不足，扩容导致Full GC）**

- 通过**Minor GC后**，**进入老年代的**平均大小**大于老年代可用内存**



##### 3.3 Major GC触发机制（忽略major GC，可认为是Full GC）

- **老年代空间不足**时，会尝试**先触发MinorGC**，如果空间还是不足，则**触发Major GC**，Major GC的速度比Minor GC**慢10倍以上**，如果Major GC，内存仍然不足，则报错OOM



#### 4. 对象什么时候去老年代？（基于Apple回收理论）

- 对象年龄超过MaxTenuringThreshold阈值（默认15），对象头的**Mark Word中有4个字节来存储对象分代年龄**，所以**最大不能超过15岁（每次GC (E区复制到S0)  或者  (E区+S0复制到S1)，年龄就加一）**
- 当S0和S1内存空间被占满时（每次GC (E区复制到S0)  或者  (E区+S0复制到S1)，年龄就加一），则存活对象直接放入老年代
- 对象超过PretenureSizeThreshold阈值大小（默认0），则直接进入老年代







## 三、垃圾回收算法

- **标记-清除算法**（Mark-Sweep）

  标记可回收的对象，然后进行清除回收

- **标记-复制算法**（Mark-Copying）

  按照容量**划分二个大小相等的内存区域**，回收垃圾时，**将存活对象复制到另一块上**，然后再**把旧的需要回收的内存空间回收掉**。

- **标记-整理算法**（Mark-Compact）

  标记可回收对象，将存活的对象都向一端移动，然后直接清除掉端边界以外的内存。

#### 1. 标记-清除算法（Mark-Sweep）

**最基础的收集算法**，将垃圾回收分为 “标记” 和 “清除” 两个阶段，**先标记出所有可回收的对象**，然后**再回收所有被标记对象所占用的空间**

![image-20220320031501501](images/image-20220320031501501.png)

其缺点很明显，如下

**优点：**实现简单，不需要对象进行移动和复制；**无需暂停用户线程**

**缺点：**标记、清除过程效率低，并会**产生大量不连续的内存碎片**，**提高了垃圾回收频率**（需要分配较大对象时**无法找到足够的连续内存**）





#### 2. 标记-复制算法（适用新生代）（Mark-Copying）

正是因为标记清除算法会产生内存碎片，所以1969年一位名叫Feniche的大神提升了标记复制的算法，复制算法理论如下：

**将内存空间划分为大小相等的两块区域**，每次只使用其中的一块。垃圾回收时，遍历当前使用的区域，**将存活对象复制到另一个区域中**，最后**将当前区域的可回收对象进行回收**。

![image-20220320031938096](images/image-20220320031938096.png)

**优点：**按顺序分配内存即可，实现简单、运行高效，**不会产生内存碎片**。

**缺点：**

- **需要暂停用户线程（如G1要冻结用户线程来复制对象）**

- **可用的内存缩小为原来的一半**，浪费空间，使该区域GC更加频繁；
- 对象**存活率高时会频繁进行复制**，开销大效率低



##### Apple回收

**现在大部分的JVM 都优先采用了 标记复制算法去回收新生代。**

**IBM**公司对“**弱分代朝生夕灭**”做过**量化研究**，**结果表明实际新生代中的对象有98%熬不过第一轮收集**。因此**并不需要按照1∶1的比例来划分新生代的内存空间**。98%的对象可被回收仅仅是“普通场景”下测得的数据，任何人都没有办法百分百保证每次回收都只有不多于10%的对象存活。

所以针对上述结论，1989年一位名叫Andrew **Appel**的大神提出了复制算法的优化版 “**半区复制分代**策略”，**把新生代分为一块较大的Eden空间和两块较小的**
**Survivor空间**，每次分配内存**只使用Eden**和**其中一块Survivor**。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也即每次新生代中可用内存空间为整个新生代容量的90%（Eden的80%加上一个Survivor的10%）

**“逃生门”**的安全设计，当**Survivor空间不足**以容纳一次Minor GC之后存活的对象时，就需要**依赖**其他内存区域（实际上大多就是**老年代**）进行分配担保（Handle Promotion）

每次GC (E区复制到S0)  或者  (E区+S0复制到S1)，年龄就加一。





#### 3. 标记-整理算法（适用老年代）（Mark-Compact）

因为标记复制算法会复制存活对象，只适合在朝生夕灭的新生代使用，所以1974年Edward Lueders提出了标记整理算法，算法的理论是**先标记可回收的对象**后，让**所有存活的对象都向内存空间一端移动**，使他们紧凑的排列在一起，**然后对端边界意外的内存进行回收**

**移动存活对象**并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须**全程暂停用户应用程序才能进行**

**关注吞吐量的ParallelScavenge收集器是基于标记-整理算法（暂停用户线程，提高GC效率，从而整体上提高了吞吐量）**的，而关注**低延迟的CMS收集器则是基于标记-清除算法（不暂停用户线程）**的，这也从侧面印证这点。

![image-20220320031422959](images/image-20220320031422959.png)

**优点：**

- 不会产生内存碎片
- 标记整理算法清理大块内存效率比不移动要高，所以相比于标记清楚算法，其**总体吞吐量要高很多**

**缺点：**

- 仍需要进行局部对象移动，一定程度上降低了效率
- **需要暂停用户线程（对象移动操作必须全程暂停用户应用程序才能进行，因为对象引用地址改变）**（ZGC和Shenandoah出现后标记整理得到优化，无需暂停用户线程了）



#### 4. [分代回收理论](#二、分代回收)并不是回收算法（因为网上很多把这个理论定义为算法之一）







## 四、垃圾回收器

#### 1. 垃圾回收器与垃圾回收算法的关系

垃圾回收算法分为两类，分别如下

- 对象死亡判定算法：引用计数法、可达性算法
- 垃圾回收算法：标记清除算法、标记复制算法、标记整理算法

根据堆内存不同区域的特点使用不同的回收算法进行回收，而垃圾收集器正是垃圾回收算法的落地实现



#### 2. 垃圾回收器类型及常用组合

**[JVM参数配置使用回收器](./4.JVM性能调优及排故)**

![image-20220320001803380](images/image-20220320001803380.png)

实线代表常用搭配、虚线代表有些版本不支持了。

JDK8 默认使用PS + PO

JDK9 默认使用G1

JDK14 弃用了 PS、PO、移除了CMS



#### 3. 串行回收器

**[JVM参数配置使用串行回收器](./4.JVM性能调优及排故)**

##### 3.1 Serial 回收器

新生代单线程串行回收器，采用**标记复制算法**，导致较长STW，适合在**内存分配不大**（十几兆、几十兆）的**桌面应用**或**客户端应用**

##### 3.2 Serial Old 回收器

是Serial回收器的老年代版本，不过其采用**标记整理算法**，适合在**内存分配不大**（十几兆、几十兆）的**桌面应用**或**客户端应用**



串行回收器的工作示意图

![image-20220320011349901](images/image-20220320011349901.png)

#### 4. 并行回收器

**[JVM参数配置使用并行回收器](./4.JVM性能调优及排故)**

##### 4.1 ParNew 回收器

并行回收器，与Serial GC共用了大部分代码（包括参数、算法、回收策略），采用**标记复制算法**

##### 4.2 Parallel Scavenge 回收器

**吞吐量优先**的并行回收器，采用**标记整理算法**，是JDK 1.8默认的回收器

PS供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX：GCTimeRatio参数。

大家不要异想天开地认为如果把`-XX:MaxGCPauseMillis`的值设置得更小一点就能使得系统的垃圾收集速度变得更快，**停顿时间缩短**是以**牺牲吞吐量和新生代空间为代价**换取的：系统把新生代调得小一些，收集300MB新生代肯定比收集500MB快，但这也直接导致垃圾收集发生得更频繁，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每次停顿70毫秒。**停顿时间的确在下降**，但**可用内存也少了（吞吐量也降下来了）**

##### 4.3 Parallel Old 回收器

**吞吐量优先**的并行回收器，使用**标记整理算法**，是JDK 1.8默认的回收器



并行回收器工作示意图

![image-20220320035023429](images/image-20220320035023429.png)





#### 5. CMS垃圾回收器

**[JVM参数配置使用CMS回收器](./4.JVM性能调优及排故)**

CMS（Concurrent Mark Sweep）是**尽可能缩短暂停时间的垃圾回收器**，适用于互联网交互型的服务器，采用**标记-清除算法**

##### 5.1 CMS回收过程

![image-20220320035809919](images/image-20220320035809919.png)

- **初始标记（Initial-Mark）阶段：**该阶段 **所有的工作线程**都将会因为"**Stop-the-Wold**"机制而出现**短暂的的暂停**，这个阶段的主要任务**标记GC Roots 中的根对象**。一旦标记完成后就恢复之前被暂停的的所有应用。**由于根对象比较小**，所以这里的**操作速度非常快**。
- **并发标记（Concurrent-Mark）阶段：**从GC Roots的**直接关联对象开始遍历整个引用链**的过程，这个过程**耗时较长**，但是**不需要暂停用户线程**，用户线程可以与垃圾回收器一起运行。
- **重新标记（Remark）阶段：由于并发标记阶段**，回收线程和用户线程并发执行，因此肯定会有对象引用发生变化，例如[三色标记的对象消失（虽然增量更新解决了，但仍然有BUG）](#2.2 三色标记)。所以重新标记阶段，暂停所有用户线程，然后从GC Roots根对象往下遍历白色的结点，从而**发生STW**
- **并发清除（Concurrent-Sweep）阶段:** 此阶段**使用标记-清除算法**回收死亡对象占用的内存空间。由于**不需要移动存活对象**，所以这个阶段可以**与用户线程同时并发运行**。

其中**初始标记**、**重新标记**这两个步骤仍然**需要“Stop The World”**

##### 5.2 CMS为什么使用标记清除算法，而不用标记整理算法？

因为**标记清除算法无需暂停用户线程**，**可以尽量减少暂停时间（因为初始标记和重新标记仍然会STW）**，正是CMS诞生的目的

##### 5.3 CMS优点

- 基于标记清除算法，不暂停用户线程，**减少了暂停时间（因为初始标记和重新标记会STW）**

##### 5.4 CMS缺点

- CMS收集器**比较吃CPU性能**。（当CPU核心数不足四个时， CMS会**导致用户CPU资源紧缺而执行变慢**）

- 并发清理阶段产生的 **“浮动垃圾”**，可能**导致老年代预留的空间不足**，**无法满足程序正常运行**（新分配的老年代对象），就会**出现”并发失败“（Concurrent Mode Failure）**。启动备用预案： **暂停用户线程的执行**， 临时**启用Serial Old收集器**来重新进行老年代的垃圾收集， 这就导致长时间停顿的Full GC。
  - CMS**并发清理阶段**，**此时此时用户线程产生的可回收对象并未被标记**，只能留到下次GC清理，这个称为**”浮动垃圾“**
  - 由于CMS线程和用户线程**并发执行**，为了**保证CMS回收垃圾时，程序也能正常运行**，因此在CMS执行回收时得**确保老年代有预留足够得内存空间供用户线程运行**。

  **-XX:CMSInitiatingOccupancyFraction**  CMS的触发百分比，值大则降低GC频率但是容易并发失败（**浮动垃圾导致可用内存小了，导致吞吐量差**），值小则避免并发失败但是GC频率UP
  
- CMS是基于标记-清除算法的回收器，**会产生内存碎片**

- 重新标记阶段可能STW时间会比较长





#### 6. G1垃圾回收器（分区回收）

**[JVM参数配置使用G1回收器](./4.JVM性能调优及排故)**

G1（Garbage First）是**在可控的暂停时间内（默认停顿时间为200ms），最大化吞吐量**的垃圾回收器，需要多核和大内存的支撑

-XX:MaxGCPauseMillis  **预期收集停顿时间**，默认值是**200毫秒**，如果预期**暂停时间设置太短，如20ms**，**暂停时间短导致GC效果差如CMS**，**GC效果差导致可用内存小了从而使吞吐量差**

-XX:G1HeapRegionSize   设定Region，取值范围为1MB～32MB，且应为2的N次幂

##### 6.1 逻辑分代

G1面向堆内存任何部分来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代，而是**哪个块存放的垃圾数量最多，回收收益最大**，这就是G1收集器的Mixed GC模式。

虽然G1也仍是遵循**分代收集理论设计（逻辑分代）**，但其**堆内存的布局发生很大变化**：G1不在将堆内存划分为固定大小的新生代和老年代，而是**把连续的堆划分为多个大小相等的独立区域（Region）**，每一个Region都可以根据需要，**扮演**新生代的**Eden空间**、**Survivor空间**、**老年代空间**。收集器能够对扮演**不同角色的Region采用不同的策略去处理**，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。

Region中还有一类特殊的**Humongous区域**，专门用来**存储大对象**。容量**超过1.5个Region为大对象**。而对于那些超过了整个Region容量的**超级大对象被存放在N个连续的Humongous Region之中**，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待

![image-20220307031639621](images/image-20220307031639621.png)

##### 6.2 G1回收过程

![image-20220320012324657](images/image-20220320012324657.png)

- **初始标记：**和CMS 初始标记相同
- **并发标记：**和CMS 并发标记相同
- **最终标记：**和CMS的重新标记相同，回收线程和用户线程并发执行，因此肯定会有对象引用发生变化，例如[三色标记的对象消失](#2.2 三色标记)。所以才有最终标记阶段，只需**遍历判断白色对象是否有引用指向自己（使用记忆集）**。
- **筛选回收：**对**各个块（Region）的回收价值和时间成本进行排序**，根据**用户所期望的停顿时间选择价值大的块**，把**选中的块的部分存活对象复制到空的块中**，然后**将新块整理移动挤压到内存的一端**，然后**将旧块的空间全部回收掉**

##### 6.3 为什么G1有三个阶段是暂停用户线程的，不是追求低暂停时间吗?

从G1的回收过程看，**G1收集器除了并发标记外，其余阶段也是要完全暂停用户线程的**，换言之，它**并非纯粹地追求低延迟**，官方给它设定的目标是**在延迟可控的情况下**获得**尽可能高的吞吐量**，所以才能担当起“全功能收集器”的重任与期

从Oracle官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回收一部分Region，停顿时间是用户可控制的，所以并不迫切去实现，而选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）中。另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了**保证吞吐量**所以才**选择了完全暂停用户线程的标记复制算法和标记整理算法**

##### 6.4 G1优点

1. G1从**整体**来看是基于**标记-整理算法**实现的收集器，但从局部（**两个Region之间**）上看又是基于**标记-复制算法**实现，**不产生内存碎片**
2. G1的**暂停时间可控**，在规定时间内，**选中并回收那些价值最大的Region**（吞吐量最大化）

##### 6.5 G1缺点

- G1是要冻结用户线程来复制对象

- 它的**每个Region都维护有自己的记忆集（卡表）**，G1的**记忆集（卡表）**在存储结构的**本质上是一种哈希表**，[区别于其他收集器使用的卡表](#5. 记忆集)，**Key是指向自己的Region的指针（谁指向我），Value是一个集合（元素是卡表的索引号，我指向谁）**。这种“双向”的卡表结构比原来的卡表实现起来更复杂，同时由于**Region数量比传统收集器的分代数量要多得多**，因此G1收集器要比其他的传统垃圾收集器有着**更高的内存占用负担**。根据经验，这导致G1的记忆集（和其他内存消耗）可能会占整个堆容量的20%乃至更多的内存空间
- 如果预期**暂停时间设置太短，如20ms**，**暂停时间短导致GC效果差如CMS**，**GC效果差导致可用内存小了从而使吞吐量差**





#### 7. CMS和G1的选择

- 目前对于4G~6G以下的堆内存，CMS的性能大概率会优于G1。

- 而在大内存6G~8G之间的堆内存，则G1大多能发挥其优势

  CMS和G1优劣势的**Java堆容量平衡点**通常在**6GB至8GB之间**。不同应用需要量体裁衣地实际测试才能得出最合适的结论，随着HotSpot的开发者对G1的不断优化，也会让对比结果继续向G1倾斜。





#### 8. 低延迟垃圾收集器

衡量垃圾收集器的三项最重要的指标是：内存占用（Footprint）、吞吐量（Throughput）和延迟（Latency）。CMS注重延时，但是吞吐量比较差（回收效率低，导致垃圾堆积快，从而Full GC）。

ZGC和Shenandoah的目标是高度相似的，都希望在尽可能对吞吐量影响不太大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。

ZGC和Shenandoah收集器使用读屏障（Read Barrier）技术**实现了标记整理算法与用户线程的并发执行**。

如果说RedHat公司开发的Shen-andoah像是Oracle的G1收集器的实际继承者的话，那Oracle公司开发的ZGC就更像是Azul System公司独步天下的PGC（PauselessGC）和C4（Concurrent Continuously Compacting Collector）收集器的同胞兄弟。

- ZGC收集器是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的，以低延迟为首要目标的一款垃圾收集器。

![image-20220320065800709](images/image-20220320065800709.png)
