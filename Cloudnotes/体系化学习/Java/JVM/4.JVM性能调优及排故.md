[toc]

### 内存泄漏与内存溢出

![image-20220306023524677](images/image-20220306023524677.png)





### JVM调优——参数类型

![image-20220306024358865](images/image-20220306024358865.png)





### JVM调优——参数

##### 1. 标准参数

![image-20220306024756948](images/image-20220306024756948.png)

##### 2. 非标准参数

![image-20220306025624917](images/image-20220306025624917.png)

##### 3. 非稳定参数

![image-20220306050849551](images/image-20220306050849551.png)

###### 回收器参数补充：

- -XX:+UseSerialGC = Serial New (DefNew) + Serial Old小型程序。默认情况下不会是这种选项，HotSpot会根据计算及配置和JDK版本自动选择收集器
- -XX:+UseParNewGC = ParNew + SerialOld这个组合已经很少用（在某些版本中已经废弃）
- **-XX:+UseConc(urrent)MarkSweepGC** = ParNew + CMS + Serial Old
- **-XX:+UseParallelGC** = Parallel Scavenge + Parallel Old (1.8默认) 【PS + SerialOld】
- **-XX:+UseParallelOldGC** = Parallel Scavenge + Parallel Old
- **-XX:+UseG1GC** = G1

###### 内存参数补充：

- **-XX:MetaspaceSize**  元空间初始值
- **-XX:NewRatio**  年轻代和老年代大小比值，取值为整数，默认为2  无需修改
- **-XX:SurvivorRatio**  Eden区与Survivor区大小的比值，取值为整数，默认为8  无需修改

###### 同步锁参数补充

- -XX:+PrintAssembly  参数输出反汇编

- -XX:+UseBiasedLocking   偏向锁开启
- -XX:BiasedLockingStartupDelay = 4000 偏向锁启动延时
- -XX:PreBlockSpin  自旋次数





### JVM调优——性能指标及步骤

#### 1. 性能指标

- 吞吐量：用户代码时间 /（用户代码执行时间 + 垃圾回收时间），也就是**CPU运行用户代码的时间** / **CPU总消耗时间**的比值

- 响应时间：STW越短，响应时间越好
- 内存占用：Java堆占用内存大小
- 垃圾回收的频率

**所谓调优：吞吐量优先，还是响应时间优先？还是在缩短STW的的情况下，要求达到多大的吞吐量。。。**

吞吐量优先的一般用：（PS + PO）

响应时间：网站 GUI API （G1）





#### 2. 调优步骤

##### 2.1 要明白为什么要调优？

**JVM运行环境（慢，卡顿）**、解决JVM运行过程中**出现的各种问题(OOM、CPU过载)**，产生系统瓶颈。

- 在**硬件资源不变**的情况下，**调整内存分配**和**合适的回收器**来最大程度**降低GC对系统的影响**。
- 通过工具对线程长时间阻塞、甚至死锁、CPU过载进行分析，并作出优化。



##### 2.2 如何分析？

使用[JConsole、VisualVM可视化工具](#调优-可视化工具)和[GC日志工具](#GC日志工具)，查看**堆内和方法区内存使用情况**、**线程信息**、**GC情况**和**CPU使用率**。

比如

1. 如**Mino GC和Full GC频率和耗时**（主要是对内存划分、垃圾回收器的选择）
   - Mino GC 执行 大于200 ms，几秒一次
   - Full GC 执行大于 1 s，半小时-一小时一次
2. 避免大量**线程长时间阻塞挂起**，如何发现原因。
3. 避免出现死锁，导致CPU使用率过高，影响其他线程工作。









### JVM调优——工具

![image-20220306030537431](images/image-20220306030537431.png)

#### 调优-常用指令

##### 1. jinfo

`jinfo [option] <pid>`

- options参数解释：
  - no options 输出所有的系统属性和参数
  - -flag 打印指定名称的参数
  - -flag [+|-] 打开或关闭参数
  - -flag = 设置参数
  - -flags 打印所有参数
  - -sysprops 打印系统配置

- 示例

  ```sh
  jinfo 11666
  jinfo -flags 11666
  jinfo -sysprops 11666
  jinfo -flag PrintGC 11666
  ```

  

##### 1. jps

`jps [options] [hostid]`

- options：
  - -l 输出jar包路径，类全名
  * -m 输出主类名，及传入main方法的参数
  * -v 输出主类名，及输出JVM参数
  * -q 显示进程id

- hostid : 主机或其他服务器ip

##### 2. jstat

`jstat [option] VMID [interval] [count ]`

其中VMID是进程id，interval是打印间隔时间（毫秒），count是打印次数（默认一直打印）

option参数解释：

- -class class loader的行为统计
- **-compiler HotSpt JIT编译器行为统计**
- **-gc 垃圾回收堆的行为统计（GC统计的实际值）**
- **-gcutil 垃圾回收统计概述（GC统计的百分比）**
- -gccapacity 各个垃圾回收代容量(young,old,perm)和他们相应的空间统计
- **-gccause 垃圾收集统计概述（同-gcutil），附加最近两次垃圾回收事件的原因**
- **-gcnew 新生代行为统计**
- -gcnewcapacity 新生代与其相应的内存空间的统计
- **-gcold 年老代和永生代行为统计**
- **-gcoldcapacity 年老代行为统计**
- -printcompilation HotSpot编译方法统计

![image-20220306032549258](images/image-20220306032549258.png)

![image-20220306033134277](images/image-20220306033134277.png)

##### 3. jstack

`jstack [options] <pid>`

option参数解释：

- -F 当使用 `jstack <pid>`无响应时，强制输出线程堆栈。
- -m 同时输出java堆栈和c/c++堆栈信息(混合模式)
- -l 除了输出堆栈信息外，还显示关于锁的附加信息

###### cpu占用过高问题

**Linux：**

1. top命令，然后按shift+p按照CPU排序，找到占用CPU过高的进程的pid
2. top -H -p [进程id] 找到进程中消耗资源最高的线程的id
3. 使用计算器讲 线程十进制id 转换成16进制
4. 使用`jstack -l <pid> |grep -A 10 线程id ` 查看CPU占用过高进程堆栈
5. 线程快照中找到指定线程，并分析代码

**Windows：**

1. 使用Process Explorer工具找到cpu占用率较高的线程
2. 在thread卡中找到cpu占用高的线程id
3. 使用计算器讲 线程十进制id 转换成16进制
4. 使用`jstack -l <pid> |grep -A 10 线程id ` 查看CPU占用过高进程堆栈
5. 线程快照中找到指定线程，并分析代码

![image-20220306163014851](images/image-20220306163014851.png)

![image-20220306163026458](images/image-20220306163026458.png)

![image-20220306162742787](images/image-20220306162742787.png)

###### jstack检查死锁问题

`jstack -l <pid> | grep deadlock`

打印结果如下：Thread-1和Thread-0分别锁住了`xxxxxx1dc5c8` 和 `xxxxx1dc5d8`，然后又想分别去获取对方持有的锁，导致死锁。

![image-20220319011514218](images/image-20220319011514218.png)



#### 调优-可视化工具

可视化监控访问远程Java程序时，需要远程程序开启**JMX，如下配置**

```sh
-Dcom.sun.management.jmxremote.port=9999 #指定端口
-Dcom.sun.management.jmxremote.authenticate=false #指定是否需要密码验证
-Dcom.sun.management.jmxremote.ssl=false #指定是否使用SSL通讯
```

##### 1. Jconsole

**JDK中自带**的 java监控和管理控制台，用于对 **JVM内存，线程 和 类等的监控**，是一个基于JMX（java management extensions）的GUI性能监测工具，直接在 **jdk/bin目录下点击jconsole.exe即可启动**

![image-20220306040829972](images/image-20220306040829972.png)

![image-20220306040841449](images/image-20220306040841449.png)



###### 内存监控

![image-20220306041336692](images/image-20220306041336692.png)

![image-20220306040936492](images/image-20220306040936492.png)

从图中详细信息可以看出，**Eden区的内存大小为27.328KB**，所以折线图中显示**每次到27Mb左右时系统就会进行一次GC**。当1000次循环结束后，执行System.gc()，柱状图中显示Eden区和Survivor区基本被清空，但老年代的对应柱状图仍保持峰值状态，这是因为System.gc()是在fillHeap()方法内执行，所以list**对象在System.gc()执行时仍然是存活的(处于作用域之内、被引用**)。如果将System.gc()移动到fillHeap()方法外执行，如下柱状图所示，则会回收包括老年代的所有内存。



###### 线程监控

![image-20220306041727848](images/image-20220306041727848.png)







##### 2. Jvisualvm

VisualVM基于NetBeans平台开发，因此它一开始就具备了插件扩展的特性，通过插件支持，VisualVM可以做许多事情，例如:

- 显示虚拟机进程和进程的配置、环境信息(jps、jinfo)
- **监视应用程序的CPU、GC、堆、方法区及线程的信息(jstat、jstack)**
- **dump及分析堆转储快照(jmap、jhat)**
- 方法级的程序运行性能分析, 找出被调用最多、运行时间最长的方法
- 离线程序快照: 收集程序的运行时配置、线程dump、内存dump等信息建立一个快照, 可以将快照发送开发者处进行bug反馈等等

在 %JAVA_HOME%\bin目录下, **启动 jvisualvm.exe**进入主界面, 点击  "工具"   →   "插件"   →   "可用插件"   选项, 选择所需的插件安装。

![image-20220306042334257](images/image-20220306042334257.png)

安装好插件后, 选择一个正在运行的java程序就可以查看程序监控的主界面了

![image-20220306042602648](images/image-20220306042602648.png)

###### 堆dump快照

两种方式生成堆dump文件

- 在"应用程序"窗口中右键单击应用程序节点，选择  "堆 Dump"
- 在"监视"页签中选择"堆 Dump"

![image-20220306042906408](images/image-20220306042906408.png)



###### 分析

在Profiler页签中，可以对程序运行期间方法级的CPU和内存进行分析，这个操作会对程序运行性能有很大影响，所以**一般不再生产环境使用Profiler**。CPU分析将会统计每个方法的执行次数、执行耗时；内存分析则会统计每个方法关联的对象数及对象所占空间。

![image-20220306043137333](images/image-20220306043137333.png)









### GC日志工具

GC日志可视化分析工具GCeasy和GCviewer。通过GC日志可视化分析工具，我们可以很方便的看到JVM各个分代的内存使用情况、垃圾回收次数、垃圾回收的原因、垃圾回收占用的时间、吞吐量等，这些指标在我们进行JVM调优的时候是很有用的。

- **GCeasy** 是一款在线的GC日志分析器，可以通过GC日志分析进行**内存泄露检测**、**GC暂停原因分析**、**JVM配置建议优化**等功能，而且是可以免费使用

  在线分析工具 https://gceasy.io/index.jsp

- GCViewer是一款实用的GC日志分析软件，免费开源使用，你**需要安装jdk或者java环境才可以使用**。软件为GC日志分析人员提供了强大的功能支持，有利于大大提高分析效率



#### GCeasy使用如下

- 通过`-Xloggc:D://logs/gc.log` 指令在指定路径下生成gc log，登陆https://gceasy.io/index.jsp并将log文件上传

  ![image-20220306043930035](images/image-20220306043930035.png)

- **jvm堆**

  ![image-20220306044436554](images/image-20220306044436554.png)

- **关键性能指标**

  ![image-20220306044719666](images/image-20220306044719666.png)

- 交互式图表

  ![image-20220306045200539](images/image-20220306045200539.png)



#### GCViewer使用如下

下载： https://sourceforge.net/projects/gcviewer /

启动：`java -jar gcviewer-1.37-SNAPSHOT.jar`

![image-20220306045450772](images/image-20220306045450772.png)

点击  File->Open File 打开我们的GC日志，可以看到如下图，图标是可以放大缩小的，主要内容就是红线圈住的部分，里面的内容跟上面的GCeasy的比较类似，具体的可以看下GitHub中的描述。

![image-20220306045521928](images/image-20220306045521928.png)





### 常见JVM调优的问题和原因

![image-20220306050429541](images/image-20220306050429541.png)

![image-20220306051159167](images/image-20220306051159167.png)





### 调优案例

![image-20220306051645521](images/image-20220306051645521.png)

![image-20220306052032351](images/image-20220306052032351.png)

![image-20220306052610257](images/image-20220306052610257.png)

![image-20220306052918567](images/image-20220306052918567.png)

![image-20220306052955042](images/image-20220306052955042.png)

![image-20220306053130950](images/image-20220306053130950.png)

