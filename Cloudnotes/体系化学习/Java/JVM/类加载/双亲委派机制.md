#### 0.类加载器简介
JVM虚拟机加载类时需要使用类加载器，Java提供多个类加载器，如下：
- Bootstrap ClassLoader 启动类加载器，主要负责加载Java核心类库，%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar和class等。
- Extention ClassLoader 标准扩展类加载器，主要负责加载目录%JRE_HOME%\lib\ext目录下的jar包和class文件。
- Application ClassLoader 
应用类加载器/系统加载器 ，主要负责加载当前应用的classpath下的所有类
- User ClassLoader 用户自定义类加载器 ， 用户自定义的类加载器,可加载指定路径的class文件

![image](https://img-blog.csdn.net/20180509200246816?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L3Bvb3JDb2Rlcl8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

###### 扩展：
###### 1. ClassLoader.loadClass(String name, boolean resolve)，resolve是否链接
###### 2. ClassLoader.findClass(String name) 没有实现，直接抛出了ClassNotFoundException异常
###### 3. ClassLoader.defineClass(String name, java.nio.ByteBuffer b,ProtectionDomain protectionDomain) 将字节流解析成Class对象
###### 4. AppClassLoader和ExtClassLoader继承于URLClassLoader继承于SecureClassLoader继承于ClassLoader
###### 5. URLClassLoader实现findClass方法，通过类名获取对应字节码流，然后通过ClassLoader.defineClass方法解析成Class对象返回。
###### 6.AppClassLoader和ExtClassLoader都是Launcher的内部类，Java应用在启动前，JVM创建Launcher初始化程序运行所需要的类加载器。Launcher初始化时，首先初始化ExtClassLoader，然后将ExtClassLoader作为父类加载器初始化AppClassLoader。ExtClassLoader没有父类加载器（在loadClass中，没有父类加载器时委托给启动类加载器）

```
public Launcher() {
        Launcher.ExtClassLoader var1;
        try {
        //先初始化了个ExtClassLoader
            var1 = Launcher.ExtClassLoader.getExtClassLoader();
        } catch (IOException var10) {
            throw new InternalError("Could not create extension class loader", var10);
        }

        try {
        //初始化了个AppClassLoader,然后把ExtClassLoader作为AppClassLoader的父loader
            this.loader = Launcher.AppClassLoader.getAppClassLoader(var1);
        } catch (IOException var9) {
            throw new InternalError("Could not create application class loader", var9);
        }
        //把初始化的AppClassLoader 作为全局变量保存起来，并设置到当前线程contextClassLoader
        Thread.currentThread().setContextClassLoader(this.loader);
        String var2 = System.getProperty("java.security.manager");
        if(var2 != null) {
            SecurityManager var3 = null;
            if(!"".equals(var2) && !"default".equals(var2)) {
                try {
                    var3 = (SecurityManager)this.loader.loadClass(var2).newInstance();
                } catch (IllegalAccessException var5) {
                    ;
                } catch (InstantiationException var6) {
                    ;
                } catch (ClassNotFoundException var7) {
                    ;
                } catch (ClassCastException var8) {
                    ;
                }
            } else {
                var3 = new SecurityManager();
            }

            if(var3 == null) {
                throw new InternalError("Could not create SecurityManager: " + var2);
            }

            System.setSecurityManager(var3);
        }

    }
```

###### 7. AppClassLoader和ExtClassLoader最终调用的还是ClassLoader.loadClass()加载类，遵守了双亲委派机制
###### 8.命名空间：每个类加载器都有自己的命名空间，存放在各自加载的Class对象；由该加载器及所有父加载器所加载的类组成。即子加载器所加载的类能访问到父加载器加载的类，但父加载器所加载的类不能访问子加载器所访问的类；同一个命名空间中只能有一个类的完整名字(包括类的包名)的Class对象；不同命名空间的类互不可见
###### 9.由于父类加载器加载的类无法访问子类加载器加载的类，比如加载DriverManager时，静态代码块中调用了SPI服务————加载classpath下所有java.sql.Driver的实现（数据库连接驱动），驱动管理器类在rt.jar下，所以使用的是启动类加载器，而java.sql.Driver具体实现在第三方jar中（如mysql包）无法被启动类加载器加载。所以java引入了线程上下文加载器，线程上下文加载器默认保存的是Appclassloader。


#### 1、什么是双亲委派？ 
当一个类加载器收到类加载的请求时，并不会直接去加载，而是委托给它的上层类加载器，直到Bootstrap。当父类加载器无法加载时，才会由当前类加载器加载。


#### 2、为什么需要双亲委派，不委派有什么问题？ 
- 防止重复加载
- 防止API篡改

类加载器的层级关系决定了加载的优先级，当父类加载器已经加载过某个类了，子类加载器将不再加载而是直接返回加载过的类

有效避免了用户自定义同包同名的JAVA API被加载，如java.lang.Integer，Integer类被Bootstrap加载器加载后，将不再加载用户自定义类，而是直接返回java类库中的Integer


#### 3、"父加载器"和"子加载器"之间的关系是继承的吗？ 
不是，采用的是组合关系（has a）即调用子加载器的方法实现功能
父类加载器通过构造函数传参初始化


#### 4、双亲委派是怎么实现的？
双亲委派的实现逻辑在ClassLoader.loadClass()方法中。当类请求加载时，首先调用findLoadedClass()检查该类是否已加载过（若是直接返回）；如果未加载则委托给父类加载器加载，如果父类加载器不存在则交给BootStrapt加载器加载；如果仍未加载成功，则调用自身findClass()方法加载。

```
protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
{
    synchronized (getClassLoadingLock(name)) {
        // 首先，检查请求的类是否已经被加载过了
        Class<?> c = findLoadedClass(name);
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                if (parent != null) {
                 //如果找不到，则委托给父类加载器去加载
                    c = parent.loadClass(name, false);
                } else {
                 //如果没有父类，则委托给启动加载器去加载
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // ClassNotFoundException thrown if class not found
                // from the non-null parent class loader
            }

            if (c == null) {
                // If still not found, then invoke findClass in order
                // to find the class.
               //如果还是没有找到，再调用本身的findClass 方法来进行类加载
                long t1 = System.nanoTime();
                c = findClass(name);

                // this is the defining class loader; record the stats
                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                sun.misc.PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {//是否需要在加载时进行链接
            resolveClass(c);
        }
        return c;
    }
}
```


#### 5、我能不能主动破坏这种双亲委派机制？怎么破坏？
自定义一个类加载器，继承URLClassloader并重写loadClass方法。不要调用父类加载器去加载就行。

JAVA API中也存在破坏双亲委派的案例，如JDBC中加载DriverManager时，会初始化实现了SPI服务接口的具体实现，此时DriverManager的加载类BootstrapClassloader无法加载这些实现类，便使用了线程上下文加载器。


#### 6、为什么重写loadClass方法可以破坏双亲委派，这个方法和findClass（）、defineClass（）区别是什么？ 
因为双亲委派的具体实现（首先检查是否已加载->委托给父类加载->父类加载失败->该加载器加载）在loadClass方法中；fundcClass方法主要获取加载类对应的字节码流然后调用defineClass解析成Class对象


#### 7、说一说你知道的双亲委派被破坏的例子吧 
1. JDBC这种需要加载SPI接口实现类的情况
1. 热插拔热部署工具为了让代码动态生效而无需重启，把模块连同类加载器一起换掉就实现了代码的热替换。
1. tomcat等web容器


#### 8、为什么JNDI、JDBC等需要破坏双亲委派？ 
JAVA API中也存在破坏双亲委派的案例，如加载DriverManager时，静态代码块中调用了SPI服务————加载classpath下所有java.sql.Driver的实现（数据库连接驱动），驱动管理器类在rt.jar下，所以使用的是启动类加载器，而java.sql.Driver具体实现在第三方jar中（如mysql包）无法被启动类加载器加载。所以java引入了线程上下文加载器，线程上下文加载器默认保存的是Appclassloader。

```
ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class);
```

```
public static <S> ServiceLoader<S> load(Class<S> service) {
    ClassLoader cl = Thread.currentThread().getContextClassLoader();
    return ServiceLoader.load(service, cl);
}
```



#### 9、为什么TOMCAT要破坏双亲委派？ 
一个web容器可能需要部署多个应用程序。
不同的应用程序可能会依赖同一个第三方类库的不同版本，但是不同版本的类库中某一个类的全路径名可能是一样的。

如果采用默认的双亲委派类加载机制，那么是无法加载多个相同的类。

所以，Tomcat破坏双亲委派原则，提供隔离的机制，为每个web容器单独提供一个WebAppClassLoader加载器。

Tomcat的类加载机制：为了实现隔离性，优先加载 Web 应用自己定义的类，所以没有遵照双亲委派的约定，每一个应用自己的类加载器——WebAppClassLoader负责加载本身的目录下的class文件


##### 扩展
![image](https://upload-images.jianshu.io/upload_images/4236553-89bacc3467d513f0.png?imageMogr2/auto-orient/strip|imageView2/2/w/462/format/webp)

###### tomcat启动类BootStrap的初始化方法：
```
ClassLoader commonLoader = null;
    ClassLoader catalinaLoader = null;
    ClassLoader sharedLoader = null;


// ------------------------- Private Methods

private void initClassLoaders() {
    try {
        commonLoader = createClassLoader("common", null);
        if( commonLoader == null ) {
            // no config file, default to this loader - we might be in a 'single' env.
            commonLoader=this.getClass().getClassLoader();
        }
        catalinaLoader = createClassLoader("server", commonLoader);
        sharedLoader = createClassLoader("shared", commonLoader);
    } catch (Throwable t) {
        handleThrowable(t);
        log.error("Class loader creation threw exception", t);
        System.exit(1);
    }
}
```
###### 类加载器加载路径配置：tomcat/conf/catalina.properties

```
common.loader=${catalina.base}/lib,${catalina.base}/lib/*.jar,${catalina.home}/lib,${catalina.home}/lib/*.jar
server.loader=
shared.loader=
```
###### 0.commonLoader、catalinaLoader和sharedLoader加载器并没有对应类，实例都是URLClassLoader


###### 1. commonLoader：Tomcat最基本的类加载器，加载路径由/conf/catalina.properties配置，默认为/lib下所有类；没有指定parent，所以父类为BootstrpClassLoader；实例为URLClassLoader；加载的类可以被Tomcat容器本身以及各个Webapp访问；


###### 2. catalinaLoader：Tomcat容器私有的类加载器，加载路径由/conf/catalina.properties配置，默认为空；为空则使用commonLoader实例，实例为URLClassLoader，否则其父类为commonLoader；加载的类只对容器本身可见；


###### 3. sharedLoader：各个Webapp共享的类加载器，加载路径由/conf/catalina.properties配置，默认为空；为空则使用commonLoader实例,实例为URLClassLoader，否则其父类为commonLoader；加载的类只对所有Webapp可见；


###### 4. WebappClassLoader：各个Webapp私有的类加载器，加载路径为/webapp/项目/WEB-INF下所有类(项目classpath下)；继承URLClassLoader，父类加载器为App ClassLoader；加载的类只对当前Webapp可见；


###### 5. JasperLoader：加载范围仅仅是这个JSP文件所编译出来的那一个.Class文件，它出现的目的就是为了被丢弃：当Web容器检测到JSP文件被修改时，会替换掉目前的JasperLoader的实例，并通过再建立一个新的Jsp类加载器来实现JSP文件的HotSwap功能。




#### 10、谈谈你对模块化技术的理解吧！