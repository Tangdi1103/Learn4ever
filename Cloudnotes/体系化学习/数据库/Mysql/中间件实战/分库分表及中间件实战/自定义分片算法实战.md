[toc]

### 一、 回顾分片策略

##### 1. 分片策略

我们在学习ShardingSphere时，有讲到Sharding-JDBC的分片策略由分片算法和分片键组成，回顾分片策略有如下几种：

- **StandardShardingStrategy(标准分片策略)**

  只支持单分片键，提供对SQL语句中的=, >, <, >=, <=, IN和BETWEEN AND的分片操作支持。

  提供PreciseShardingAlgorithm和RangeShardingAlgorithm两个分片算法。

  PreciseShardingAlgorithm是必选的，RangeShardingAlgorithm是可选的。但是SQL中使用了范围操作，如果不配置RangeShardingAlgorithm会采用全库路由扫描，效率低。

- ComplexShardingStrategy(复合分片策略)

  支持多分片键。提供对SQL语句中的=, >, <, >=, <=, IN和BETWEEN AND的分片操作支持。由于多分片键之间的关系复杂，因此并未进行过多的封装，而是直接将分片键值组合以及分片操作符透传至分片算法，完全由应用开发者实现，提供最大的灵活度

- **InlineShardingStrategy(行表达式分片策略)**

  只支持单分片键。使用Groovy的表达式，提供对SQL语句中的=和IN的分片操作支持，对于简单的分片算法，可以通过简单的配置使用，从而避免繁琐的Java代码开发。如: t_user_$->{u_id % 8} 表示t_user表根据u_id模8，而分成8张表，表名称为t_user_0到t_user_7。

- **HintShardingStrategy(Hint分片策略)**

  通过Hint指定分片值而非从SQL中提取分片值的方式进行分片的策略。

- NoneShardingStrategy(不分片策略)

其中，InlineShardingStrategy行表达式分片策略仅仅需要在配置中，指定分片键以及分片表达式即可达到预定目标。



##### 2. 分片算法

而其他的分片策略，都需要自己实现分片算法，分片算法如下：

- **PreciseShardingAlgorithm(精确分片算法)**

  用于处理使用单一键作为分片键的=与IN进行分片的场景。

- **RangeShardingAlgorithm(范围分片算法)**

  用于处理使用单一键作为分片键的BETWEEN AND、>、<、>=、<=进行分片的场景。

- **ComplexKeysShardingAlgorithm(复合分片算法)**

  使用多键作为分片键进行分片的场景，多个分片键的逻辑较复杂，需要应用开发者自行处理其中的复杂度

- **HintShardingAlgorithm(Hint分片算法)**

  由其他外置条件决定的场景，可使用SQL Hint灵活的注入分片字段。例：内部系统，按照员工登录主键分库，而数据库中并无此字段。SQL Hint支持通过Java API和SQL注释两种方式使用



### 二、标准分片策略实战

StandardShardingStrategy策略必须实现精确分片算法，可实现范围分片算法。

现有order表，需按年进行分库，按月进行分表

##### 1. 思路

- 实现精准分片算法和范围分片算法
- 使用精准分片算法对表进行按年分库和按月分表
- 使用范围分片算法进行范围查询



##### 2. 实现精确分片算法

- 实现接口 `PreciseShardingAlgorithm`
- `doSharding` 方法参数介绍
  - collection：存放的分库或分表后，库或者表的列表
  - preciseShardingValue：分片值，即SQL中的分片键对应的值

**库分片算法**

```java
public class PreciseModuloDatabaseShardingAlgorithm implements PreciseShardingAlgorithm<String> {

    @Override
    public String doSharding(Collection<String> collection, PreciseShardingValue<String> preciseShardingValue) {
        //对于库的分片collection存放的是所有的库的列表，这里代表dataSource_2017~dataSource_2020
        //配置的分片的sharding-column对应的值
        String timeValue = preciseShardingValue.getValue();
        //分库时配置的sharding-column
        String time = preciseShardingValue.getColumnName();
        //需要分库的逻辑表
        String table = preciseShardingValue.getLogicTableName();
        if(StringUtils.isBlank(timeValue)){
            throw new UnsupportedOperationException("preciseShardingValue is null");
        }
        //按年路由
        for (String each : collection) {
            String value = StringUtils.substring(timeValue,0,4); //获取到年份
            if(each.endsWith(value)){
               // //这里返回回去的就是最终需要查询的库名
                return each;
            }
        }
        throw new UnsupportedOperationException();
    }
}
```

**表分片算法**

```java
public class PreciseModuloTableShardingAlgorithm implements PreciseShardingAlgorithm<String> {
    @Override
    public String doSharding(Collection<String> collection, PreciseShardingValue<String> preciseShardingValue) {
        //对于库的分片collection存放的是所有的库的列表，这里代表flow_01~flow_12
        //配置的分片的sharding-column对应的值
        String timeValue = preciseShardingValue.getValue();
        //分库时配置的sharding-column
        String time = preciseShardingValue.getColumnName();
        //需要分库的逻辑表
        String table = preciseShardingValue.getLogicTableName();
        if(StringUtils.isBlank(timeValue)){
            throw new UnsupportedOperationException("preciseShardingValue is null");
        }
        //按月路由
        for (String each : collection) {
            String value = StringUtils.substring(timeValue,4,6); //获取到月份
            if(each.endsWith(value)){
                //这里返回回去的就是最终需要查询的表名
                return each;
            }
        }
        return null;
    }
}
```



##### 3. 实现范围分片算法（待完成）

- 实现接口 `RangShardingAlgorithm`
- `doSharding` 方法参数介绍
  - collection：存放的分库或分表后，库或者表的列表
  - rangShardingValue：分片值，即SQL中的分片键对应的值

```java

```



##### 4. 配置

```properties
spring.shardingsphere.props.sql.show=true

#datasource
spring.shardingsphere.datasource.names=ds0,ds1

spring.shardingsphere.datasource.ds0.type=com.zaxxer.hikari.HikariDataSource
spring.shardingsphere.datasource.ds0.driver-class-name=com.mysql.jdbc.Driver
#spring.shardingsphere.datasource.ds0.jdbc-url=jdbc:mysql://192.168.95.130:3306/order2020
spring.shardingsphere.datasource.ds0.jdbc-url=jdbc:mysql://localhost:3306/order2020
spring.shardingsphere.datasource.ds0.username=root
spring.shardingsphere.datasource.ds0.password=root

spring.shardingsphere.datasource.ds1.type=com.zaxxer.hikari.HikariDataSource
spring.shardingsphere.datasource.ds1.driver-class-name=com.mysql.jdbc.Driver
#spring.shardingsphere.datasource.ds1.jdbc-url=jdbc:mysql://192.168.95.132:3306/order2021
spring.shardingsphere.datasource.ds1.jdbc-url=jdbc:mysql://localhost:3306/order2021
spring.shardingsphere.datasource.ds1.username=root
spring.shardingsphere.datasource.ds1.password=root


#sharding-database-table，配置需要被分库分表的表的分片策略（分片键、分片算法）
#先配置分库策略（根据分片键及分片算法）
spring.shardingsphere.sharding.tables.b_order.database-strategy.standard.sharding-column=create_time
spring.shardingsphere.sharding.tables.b_order.database-strategy.standard.precise-algorithm-class-name=PreciseModuloDatabaseShardingAlgorithm

#再配置分表策略（根据分片键及分片算法）
spring.shardingsphere.sharding.tables.b_order.table-strategy.standard.sharding-column=create_time
spring.shardingsphere.sharding.tables.b_order.table-strategy.standard.precise-algorithm-class-name=PreciseModuloTableShardingAlgorithm
spring.shardingsphere.sharding.tables.b_order.table-strategy.standard.rang-algorithm-class-name=RangModuloTableShardingAlgorithm
#配置分库分表的数据节点
spring.shardingsphere.sharding.tables.b_order.actual-data-nodes=ds${0..1}.b_order${2020..2021}_${1..12}
spring.shardingsphere.sharding.tables.b_order.key-generator.column=id
spring.shardingsphere.sharding.tables.b_order.key-generator.type=SNOWFLAKE

```



##### 5. 测试

```java

```







### 三、Hint分片策略实战

HintShardingStrategy策略为强制路由策略，它会忽略该表已配的其他分库分表策略，而强制使用Hint策略

Hint算法需要自己实现



##### 1. 思路

- 实现Hint算法
- 配置分库分表为Hint策略
- 使用HintManager指定路由库或表的值



##### 2. 实现Hint分片算法接口

**此处库和表分片算法一致**

```java
import org.apache.shardingsphere.api.sharding.hint.HintShardingAlgorithm;
import org.apache.shardingsphere.api.sharding.hint.HintShardingValue;

import java.util.ArrayList;
import java.util.Collection;

public class MyHintShardingAlgorithm implements HintShardingAlgorithm<Long> {
    @Override
    public Collection<String> doSharding(
            Collection<String> availableTargetNames,
            HintShardingValue<Long> shardingValue) {
        Collection<String> result = new ArrayList<>();
        for (String each : availableTargetNames){
            for (Long value : shardingValue.getValues()){
                if(each.endsWith(String.valueOf(value % 2))){
                    result.add(each);
                }
            }
        }
        return result;
    }
}
```



##### 3. 配置

```properties
spring.shardingsphere.props.sql.show=true

#datasource
spring.shardingsphere.datasource.names=ds0,ds1

spring.shardingsphere.datasource.ds0.type=com.zaxxer.hikari.HikariDataSource
spring.shardingsphere.datasource.ds0.driver-class-name=com.mysql.jdbc.Driver
spring.shardingsphere.datasource.ds0.jdbc-url=jdbc:mysql://localhost:3306/db1
spring.shardingsphere.datasource.ds0.username=root
spring.shardingsphere.datasource.ds0.password=root

spring.shardingsphere.datasource.ds1.type=com.zaxxer.hikari.HikariDataSource
spring.shardingsphere.datasource.ds1.driver-class-name=com.mysql.jdbc.Driver
spring.shardingsphere.datasource.ds1.jdbc-url=jdbc:mysql://localhost:3306/db2
spring.shardingsphere.datasource.ds1.username=root
spring.shardingsphere.datasource.ds1.password=root

#强制路由库
#spring.shardingsphere.sharding.tables.city.database-strategy.hint.algorithm-class-name=com.lagou.hint.MyHintShardingAlgorithm

#强制路由库和表 
spring.shardingsphere.sharding.tables.b_order.database-strategy.hint.algorithm-class-name=com.lagou.hint.MyHintShardingAlgorithm
spring.shardingsphere.sharding.tables.b_order.table-strategy.hint.algorithm-class-name=com.lagou.hint.MyHintShardingAlgorithm
spring.shardingsphere.sharding.tables.b_order.actual-data-nodes=ds${0..1}.b_order${0..1}
```



##### 4. 测试

```java
import com.tangdi.RunBoot;
import com.tangdi.entity.City;
import com.tangdi.repository.CityRepository;
import org.apache.shardingsphere.api.hint.HintManager;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

import javax.annotation.Resource;
import java.util.List;

@RunWith(SpringRunner.class)
@SpringBootTest(classes = RunBoot.class)
public class TestHintAlgorithm {

    @Resource
    private CityRepository cityRepository;

    @Test
    public void test1(){
        HintManager hintManager = HintManager.getInstance();
        //hintManager.setDatabaseShardingValue(0L); //由于算法中匹配value%2，所以强制路由到db0
        hintManager.setDatabaseShardingValue(1L); //由于算法中匹配value%2，所以强制路由到db1
        List<City> list = cityRepository.findAll();
        list.forEach(city->{
            System.out.println(city.getId()+" "+city.getName()+" "+city.getProvince());
        });
    }

}
```

