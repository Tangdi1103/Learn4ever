### 力扣之全排列46

```java
import java.util.ArrayList;
import java.util.List;

/**
 * @program: algorithm
 * @description: 全排列1
 * @author: Wangwt
 * @create: 13:38 2021/7/31
 * 深度优先遍历-回溯算法
 * 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。
 * 思路：深度优先遍历dfs，递归遍历到叶子节点，然后回溯，撤销上一步的操作
 * 递归终止条件：判断是否到了叶子节点，元素个数是否为树高
 * 状态变量：记录每个元素是否被选择的状态
 */
public class QuanPaiLie46 {

    public static void main(String[] args) {
        int[] nums = {1,3,6,8};

        List<List<Integer>> list = permute(nums);
        for (List<Integer> integers : list) {
            System.out.println(integers);
        }
    }

    private static List<List<Integer>> permute(int[] nums){
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        List<Integer> temp = new ArrayList<Integer>();
        boolean[] status = new boolean[nums.length];

        dfs(res,temp,nums,status,0);
        return res;
    }

    private static void dfs(List<List<Integer>> res, List<Integer> temp,  int[] nums, boolean[] status, int depth) {
        if (depth == nums.length){
            res.add(new ArrayList<Integer>(temp));
            return;
        }

        for (int i = 0; i < nums.length; i++) {
            if (status[i]){
                continue;
            }
            temp.add(nums[i]);
            status[i] = true;
            dfs(res,temp,nums,status,depth + 1);
            temp.remove(temp.size() -1);
            status[i] = false;
        }
    }
}
```

### 力扣之47全排列2

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * @program: algorithm
 * @description: 全排列2
 * @author: Wangwt
 * @create: 13:26 2021/7/31
 * 深度优先遍历-回溯算法
 * 给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。
 * 思路：深度优先遍历dfs，递归遍历到叶子节点，然后回溯，撤销上一步的操作
 * 递归终止条件：判断是否到了叶子节点，元素个数是否为树高
 * 状态变量：记录每个元素是否被选择的状态
 * 剪枝：条件是给定的数组有序，或手动排序。判断相邻的的元素是否相等，
 */
public class QuanPaiLie47 {
    public static void main(String[] args) {
        int[] nums = {1,3,1};

        List<List<Integer>> list = permute(nums);
        for (List<Integer> integers : list) {
            System.out.println(integers);
        }
    }

    private static List<List<Integer>> permute(int[] nums){
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        List<Integer> temp = new ArrayList<Integer>();
        boolean[] status = new boolean[nums.length];

        Arrays.sort(nums);
        dfs(res,temp,nums,status,0);
        return res;
    }

    private static void dfs(List<List<Integer>> res, List<Integer> temp,  int[] nums, boolean[] status, int depth) {
        if (depth == nums.length){
            res.add(new ArrayList<Integer>(temp));
            return;
        }

        for (int i = 0; i < nums.length; i++) {
            if (status[i]){
                continue;
            }

            if (i > 0 && nums[i] == nums[i-1] && !status[i - 1]){
                continue;
            }

            temp.add(nums[i]);
            status[i] = true;
            dfs(res,temp,nums,status,depth + 1);
            temp.remove(temp.size() -1);
            status[i] = false;
        }
    }
}
```

