主流程是AbstractApplicationContext的refresh()方法



容器启动流程:beanFactory实例化；

​						加载并解析xml/注解配置到BeanDefinition对象中，存入BeanDefinition注册表中；

​						遍历beanNames根据BeanDefinition，从缓存中取bean A，若没有则取实例化非抽象、单例、非延迟加载bean A，若开启循环依赖，则提前暴露，放到三级缓存singletonFactories中

​						bean A继续往下装配属性，发现依赖引用属性B，调用getBean(Bname)去获取bean B；

​						（重复A的过程）从缓存中取bean B，若没有则实例化，若开启循环依赖，则提前暴露，放到三级缓存singletonFactories

​						bean B继续往下装配属性，发现依赖引用属性bean A，调用getBean(Aname)，发现三级缓存中有bean A，取出并通过beanPostProcesser后置扩展，并放入二级缓存earlysingletonFactories中，bean B装配扩展后的A，然后继续往下初始化，最后bean B放入单例池singletonObjects中

​						bean A装配完属性B后，A继续往下初始化，最后也放入了单例池singletonObjects中

​						调用Aware实现类并执行方法

​						调用bean后置处理器的before方法

​						调用其他三个初始化方法(@PostConstruct、Beaninitliazation、init-method)

​						调用bean后置处理器的after方法



refresh()方法中主要流程是两个，一个是创建beanFactory并解析文件存入BeanDefinition，二是创建bean





<img src="images/循环依赖问题.png" alt="循环依赖问题" style="zoom:150%;" />



非抽象、单例、非延迟加载的bean，在容器启动的时候实例化，底层调用的是doGetBean()

非抽象、单例、延迟加载的bean，通过beanFactory.getBean()的时候实例化，底层调用的是doGetBean()



IoC容器是Spring的核⼼模块，是抽象了对象管理、依赖关系管理的框架解决⽅案。Spring 提供了很多的容器，其中BeanFactory 是顶层容器（根容器），不能被实例化，它定义了所有IoC 容器 必须遵从的⼀套原则，具体的容器实现可以增加额外的功能，⽐如我们常⽤到的ApplicationContext

其下更具体的实现如ClassPathXmlApplicationContext 包含了解析xml 等⼀系列的内容，
AnnotationConfigApplicationContext 则是包含了注解解析等⼀系列的内容。

Spring IoC 容器继承体系⾮常聪明，需要使⽤哪个层次⽤哪个层次即可，不必使⽤功能⼤⽽全的。

<img src="images/[K2%DRKYRAF6H1AFN3}XQPM.png" alt="img" style="zoom:150%;" />





