[toc]

## 一、Redis 的缓存问题

### 1. 缓存雪崩

定义：**Redis宕机重启**或者**大批量的Key在某时段过期**，高并发或大量的请求过来访问这些Key，穿过Redis直接落到DB，导致DB压力过大而宕机。缓存雪崩是**由于大批量的Key过期导致**

解决方案：

- Key的失效期分开（设置不同的TTL），防止某时段大批量的key同时过期
- 不设置TTL
- 搭建Redis高可用集群（RedisCluster）

### 2. 缓存击穿

定义：某些**热点Key**设置了TTL，当这些热点Key**过期**时，大量的请求并发过来访问热点Key，穿过Redis直接落到DB，导致宕机。缓存击穿只是**热点Key过期导致**

解决方案：

- 使用分布式锁，去控制这些热点Key访问的代码块
- 热点Key不设置TTL

### 3. 缓存穿透

定义：高并发或者大量的请求去查询 **不存在的key（缓存和DB都不存在）**，每次都会穿过缓存查询数据库，导致数据库压力过大而宕机

解决方案：**布隆过滤器**、或者使用Write Behind Caching Pattern（缓存优先模式）（查询只操作缓存，通过定时任务异步将DB数据加载到缓存）

- 查缓存前先去布隆过滤器查询key是否存在
- **如果不存在则直接返回**
- **如果存在则继续插缓存或DB**
- 项目启动时，将所有的key存入布隆过滤器
- 当DB新添加数据时，将key存入布隆过滤器，

![image-20220114004140070](images/image-20220114004140070.png)

#### 布隆过滤器

布隆过滤器可以用于检索一个元素是否在一个集合中，本质是**一个很长的二进制向量**和**一系列随机hash映射函数**

基本思想：当有**元素经过布隆过滤器时**，内部通过**N个Hash函数**对元素求散列值，并把**散列值映射成数组中的N个点（取模求下标），把它们置为1**。检索某个元素时，若这N个下标**有一个0**，则表示该元素**不存在**；**若都是1**，**则可能存在**（这些1可能刚好都是别的多个元素凑齐的）

![image-20220114001831444](images/image-20220114001831444.png)

### 4. 旁路缓存模式的并发问题

旁路缓存模式的更新模式为：**先更新数据库，再删除缓存。但存在并发问题**，描述如下：

update数据库但未commit，同时删除了缓存，此时有请求进来读取该key，查到了数据库更新前的数据并回填缓存，数据库commit，此时**DB和Redis的数据不一致**

![image-20220114162237575](images/image-20220114162237575.png)

#### 延时双删

针对以上并发问题导致的数据不一致，可采用延时双删策略，思路如下

- 更新数据库，同时删除缓存key
- 2秒后在删除一次缓存key
- 查询回填的缓存key设置 TTL

- 将删除失败的记录到日志，利用脚本提取失败记录再次删除（定时任务1天或者7天）





## 二

## 三

## 四

## 五