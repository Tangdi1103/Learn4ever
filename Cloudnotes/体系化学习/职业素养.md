1. 不专业的需求：无关紧要却成本巨大的需求
2. 说是：有清晰认识、明确目标、可以给出明确的期限
3. 说否：天马行空、不切实际、经不起实践考验的需求。往往花费巨大成本开发出来却不是想要的。甚至还会影响系统性能和可靠性。有一个现实的例子，IBM 的OS/360操作系统就是一个典型，啥都想要却最终沦为巨兽陷阱。
4. 正确考量：需求的目标明确否，意义和价值何在？开发成本有哪些？是否能保障程序高质量？权衡时切忌为了体现个人能力而说尝试去做、或者达不到说是的情况下接受。









1. 不专业的行为：为了赶工期而降低对程序的质量要求。
2. 代码层面：得保证程序的维护性、扩展性、可靠性都是高效的。设计模式可以很好的写出高扩展、高可维护的代码结构，最好熟练掌握多种模式。另外编程时尽量遵守SOLID设计原则。
3. 架构层面：保证整个系统的可用性、容错性都是高效的，也可说是高可用高性能高并发。需要做到这些往往意味着系统不能单单是集群甚至单体架构。将系统拆分多个细粒度的业务服务并多实例部署，这种分布式乃至微服务架构需要注意的点有很多。服务治理（服务之间互相发现、服务间调用、多实例的负载均衡、重试、防止服务雪崩的熔断和降级策略）、服务协调（分布式环境对共享资源的访问控制）、服务分布式事务（区别于单个服务内的本地事务，是由多个不同服务的本地事务共同形成的一个逻辑整体上的大事务。其实类似于单服务内多线程的不同事物形成的整体大事务）





1. 价值意义：无关紧要、毫无意义 vs 价值和意义巨大
2. 可行性：天马行空、不切实际 vs 认识清晰、目标明确
3. 开发成本：时间资源成本巨大 vs 成本不大
4. 产出：实际产出达不到验收标准、质量差 vs 达到验收标准、高质量



1. 找好下家再辞职

2. 成就与荣誉必然伴随着责任与担当，因为你无法从不需你负责的事情上获得任何荣誉和成就。

3. 还是牢记，不论将来从事什么行业都要去热爱它，必须尽职尽责。

4. 保证功能的正确性：随时写单元测试，尽可能覆盖全流程代码，尽可能多的执行这些测试。

5. 保证代码结构的灵活性：无情重构防止N久后代码僵化而无法扩展。为了证明代码易于修改，就是做些实际的修改，如果难以下手说明应该改进设计，是后续更易维护。

   为什么大多数开发人员不敢不断修改代码？因为害怕改坏代码，如果有一套覆盖了全代码的自动化测试，就可以随意疯狂地对现有代码做各种优化和修改。对冗长地方法拆分、对switch语句改为多态、多层继承改为“命令链”。

4. 职业道德：雇主没有义务花钱给你培训、教你知识、买书籍，也没义务给你留学习时间等等，职业发展是你自己的事，将其寄托于雇主的软件工程师将会很惨。如果有，则说明他们待你不薄，你应该适当表示感激，因为这些不是你理所应当该享受的，这些本不该雇主来做。雇主出了钱，你必须付出时间和精力。一周有40个小时，你应该用来解决雇主的问题，而不是你自己的问题。你应该每周计划工作60个小时，前40小时是给雇主的，后20小时是给自己的（大约每天三小时用来看书、练习、学习），**每周20小时的投入终将使我成为更有价值的专业人士**（如果为雇主做的工作让我个人的职业发展受益匪浅，则这20小时里花点时间为雇主工作也是合理的），渴望成为专业开发者吧。