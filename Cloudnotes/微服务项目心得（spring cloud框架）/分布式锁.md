分布式的集群环境下（不同JVM）中，不同节点的线程对代码和资源的同步访问---使用分布式锁

### 1.redis实现分布式锁

获得锁，value代表获得锁的线程ID


```
String threadId = Thread.currentThread.getID()

set(key,threadId,timeout)
```


释放锁，需要判断该锁value

```
if(threadId.equals(RedisClient.get(key)))
del(key)
```



#### 实际项目中的使用
```
try {
    //加分布式锁
    if(!tryLock(lockKey)) {
        //因为token有效性为一次，只要加锁失败，就意味着token已经被其他请求占有使用，本次请求直接返回失败即可。
        return new AfsAuthenticateResponse(AfsAuthCode.AUTHENTICATE_FAIL_LOCK);
    }
    // TODO 处理业务
}catch (Exception e) {
	LOGGER.error("AfsAuthenticationService.authenticate error!", e);
	return new AfsAuthenticateResponse(AfsAuthCode.AUTHENTICATE_SYS_ERROR);
} finally {
	if(StringUtils.isNotBlank(lockKey)) {
		//显式释放分布式锁
		releaseLock(lockKey);
	}
}


/**
 * 尝试加分布式锁
 * 
 * @param
 * @return
 */
private boolean tryLock(String lockKey) {
    //10秒钟后自动解锁，防止死锁。
    if("OK".equals(jedisClusterService.set(lockKey, "", "NX", "EX", 10))) {
        return true;
    }
    return false;
}

/**
* 释放Redis分布式锁
* 
* @param
* @return
*/
private void releaseLock(String lockKey) {
	try {
        jedisClusterService.del(lockKey);
    } catch (Exception e) {
        LOGGER.error("AliAfsAuthServiceImpl.releaseLock error!", e);
    }
}
```




