<font size=4>

### Spring Boot与Spring Cloud

Spring Boot的理念是“约定优于配置”，是一个简化了Spring的搭建、配置的框架，能够让项目快速的运行（运行jar，内嵌Servlet容器）起来,与构建微服务没有直接关系。---Servlet是java编写的一个类，本质是运行在Web服务器中的程序，用于浏览和修改数据，并生成动态的Web内容

Spring Cloud是一个基于Spring Boot实现微服务的框架，它的特性有高性能，高并发，高可用，包含微服务架构所需的各种组件，如下：
- 服务注册与发现中心（高可用集群）
    - 解决了“服务在哪的问题”，将所有的服务注册到一个Server，通过心跳对服务健康监测。需要调用时向注册中心拿可用的服务地址和端口（可用性的要求要高于一致性）
    - Eureka保证AP （可用性和分区容错性），只要有一台Eureka还在，就能保证注册服务可用，只不过查到的信息可能不是最新的(不保证强一致性)，Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪。
    - Zookeeper保证CP （一致性和分区容错性），当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。选举leader的时间太长，导致在选举期间注册服务瘫痪。
- 服务间通信/消费者消费提供者（不使用RPC是因为RPC难以做到负载均衡）
    - Spring Cloud提供了Ribbon+restTemplate解决“服务调用问题”，Ribbon+RestTemplate(Spring Cloud)---Ribbon基于HTTP和TCP客户端的负载均衡，RestTemplate模板提供restful远程调用，因此实现远程调用的负载均衡
    - Spring Cloud还提供Feign解决“服务调用问题”，Feign 是一个声明式的 Http 客户端 ,可直接进行远程调用，并且默认结合了Ribbon进行负载均衡
- 熔断器
    - 由于网络等原因，单个服务出现问题，调用这个服务时会造成线程阻塞，当大量请求涌入，Servlet容器的线程资源被耗尽，导致服务故障。该故障在链路上传播，从而导致整个微服务系统雪崩
    - Spring Cloud提供了熔断器Hystrix，当某个服务的调用失败频率达到一定阈值（Hystrix 是 5 秒 20 次），熔断器就会打开，通过fallback返回一个设置好的固定值，从而避免雪崩
    - Hystrix Dashboard帮助我们进行熔断仪表盘监控
- 路由网关（高可用集群）
    - 为了安全微服务的服务不能直接暴露给用户，因此需要路由网关，来负责路由转发,Spring Cloud提供了Zuul和Gateway
    - 需要注意的是，Zuul转发的请求负载高，因此所有用户的请求首先会通过Ningix负载均衡，然后到达服务路由网关Zuul集群，然后到达具体的服务。Zuul 默认和 Ribbon 结合实现了负载均衡的功能（在Zuul配置多个服务地址）。
    - Zuul还能做过滤器，过滤器继承 ZuulFilter 类并在类上增加 @Component 注解就可以使用服务过滤功能了，非常简单方便
- 分布式配置中心
    - 在分布式系统中，由于服务数量巨多，需要分布式配置中心组件，方便了服务的配置文件统一管理
    - Spring Cloud提供了分布式配置中心组件 Spring Cloud Config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程 Git 仓库中，帮助我们管理服务的配置信息。
- 链路追踪
    - 当Rest调用了一个由多个服务协同完成的接口时，如果链路上任何一个服务出现问题或者网络超时，都会形成导致接口调用失败。为了定位问题服务，所以提供了服务链路追踪
    - ZipKin 是一个开放源代码的分布式跟踪系统，每个服务向 ZipKin 报告计时数据，ZipKin 会根据调用关系通过 ZipKin UI 生成依赖关系图，显示了多少跟踪请求通过每个服务，该系统让开发者可通过一个 Web 前端轻松的收集和分析数据，例如用户每次请求服务的处理时间等，可方便的监测系统中存在的瓶颈。
- 服务监控
    - 随着开发周期的推移，一个个微服务形成了错综复杂的系统，为了收集众多服务的健康状态，并发数，会话量等信息，Spring Boot 提供了Spring Boot Admin拥有一套功能强大的监控管理系统。


---

### Zookeeper（一致性，Master选举）
zookeeper提供了一致性文件系统和通知机制，主要是用来解决分布式应用中经常遇到的一些数据管理问题，拥有一下功能：
- 命名服务：zookeeper中每个节点都有都自己的path---ZooKeeper 的命名服务即生成全局唯一的ID。
- 
- 集群管理
    - 机器注册或抹除---所有机器约定在父目录GroupMembers下创建临时目录节点，然后监听父目录节点的子节点变化消息。一旦有机器挂掉，该机器与 zookeeper的连接断开，其所创建的临时目录节点被删除，所有其他机器都收到通知：某个兄弟目录被删除，于是，所有人都知道：它上船了。新机器加入 也是类似，所有机器收到通知：新兄弟目录加入
    - 所有机器创建临时顺序编号目录节点，每次选取编号最小的机器作为master就好。
- 分布式锁
    - 分布式锁是控制分布式系统之间同步访问共享资源的一种方式（多个服务同时需要操作相同变量不安全）
    - 把ZooKeeper上的一个节点看作是一个锁，获得锁是通过创建临时节点的方式来实现。想要获得锁的服务都在zookeeper目录下创建一个临时顺序节点，序号最小的节点获得锁，没获得锁的通过Watcher监听带锁节点的变更事件，当带锁的用完删除节点并释放锁，序号最小的获得锁。
- 队列管理

---
### 线程的阻塞
- sleep():并不会释放锁；该方法让当前正在执行的线程在指定时间内暂停执行，进入阻塞状态，同优先级或更高优先级的线程获得执行权。
- wait():在synchronize中（同步代码块或者同步方法），当对象调用该方法，当前正在执行的线程暂停执行，并扔入对象的等待池内，只有在调用notify或notifyall后，该线程或所有线程进入对象的锁池中。
- yield():并不会释放锁；该方法让当前正在执行的线程重新回到可执行状态。
- join()：当前线程等待调用了join()方法的线程全部执行完后才开始执行

---

### 多线程的线程安全
- 	使用关键字volatile，表示该变量为共享变量，放于主内存中供多个线程调用
- 	使用同步锁synchronize
- 	使用ConcurrentHashMap，安全的map集合，效率高
- 	Collections类有将不安全集合转为安全的集合的方法，如：synchronizedList

---

### msql的优化---三大优化方向

- 	内核优化：算了
- 	参数优化：mysql默认的最大线程连接数是100，可以设置最大连接数，最大值为16384
- 	查询优化：为搜索的字段建立索引、不用使用select * 、 为每个表设置一个ID、可以使用ENUM而不是VARCHAR、不要使用NULL

---

### 分布式一致性（微服务中的数据一致性）
##### 为什么需要一致性

在分布式系统中，为了保证数据的高可用，通常，我们会将数据保留多个副本(replica)，这些副本会放置在不同的物理的机器上。为了对用户提供正确的 CRUD 等语义，我们需要保证这些放置在不同物理机器上的副本是一致的。

##### 解决方案
在分布式系统中，每个节点只能知道自己的操作结果，却无法知道其他节点的操作结果

分布式事务---分布式事务是指会涉及到操作多个数据库的事务

- 两阶段提交协议 (2PC)
   - 用于协调参与分布式事务的所有进程，根据反馈决定各节点是否要提交操作还是中止操作。
   - 投票阶段：向所有服务发起投票请求，服务回答 yes 或 no。如果有任何服务回复 no 以拒绝或超时，协调器则在下一阶段发送中止消息。
   - 决定阶段：如果所有服务都回复 yes，协调器则向服务发送 commit 消息，接着服务告知事务完成或失败。如果任何服务提交失败， 协调器将启动额外的步骤以中止该事务。
   - 缺点：造成阻塞；网络震荡或协调者单点故障时，只有部分节点收到提交请求，从而造成不一致。
   - 
- 消息队列(rabbitmq)
---

### 订单管理问题（单体）

通过用户ID获得用户购物车信息

从购物车库表中获得商品信息，并生成订单信息（商品信息，用户id，用户地址信息，订单号，订单状态等）

- 状态中有一个退款字段

- 付款：生成订单并提交订单已付款状态   
- 未付款：生成订单未付款状态

##### 场景

但是在提交订单时存在并发问题，大量用户同时购买，可能会出现库存不足的情况

存在脏读并发问题：一个事务读到的是另一个事务提交前的数据
##### 解决方案
加锁：同一时间只有一个事务在操作数据，

此时使用乐观锁，在表中添加version字段，每次更新时将version+1,同时判断version是否相同

比如：A节点和B节点操作相同表，同一时刻读取到version为2，操作sql：update table set column = newcolumn,version = version + 1 where version = 2;实际上只有一个节点执行成功，version为3，另一条执行则失败了

---

### MYSQL索引类型
- 普通索引： INDEX  例如：ALTER TABLE table_name ADD INDEX index_name (column_list);
    - 适用于name、email等一般属性，普通索引，一般会使用like进行模糊查询，只对前面不使用通配符的查询有效
- 唯一索引：   UNIQUE    例如：ALTER TABLE table_name ADD UNIQUE (column_list);
    - 与普通索引类似，不同的是唯一索引要求索引字段值在表中是唯一的，这一点和主键索引类似，但是不同的是，唯一索引允许有空值。唯一索引一般适用于身份证号码、用户账号等不允许有重复的属性字段上。
- 主键索引：   primary key  例如：ALTER TABLE table_name ADD PRIMARY KEY (column_list);
    - 其实就是主键，一般在建表时就指定了，不需要额外添加。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。 
- 全文索引：FULLTEXT  例如：ALTER TABLE table_name ADD FULLTEXT (column_list);
    -  只适用于VARCHAR和Text类型的字段，对于全文索引而言在查询时有自己独特的匹配方式
---

### 网络安全

全球加密方式就那么多 ，防不住定点攻击，除非私有协议(加密解密算法)

服务都放docker中，实现局域网内服务间通信，对外物理隔绝，绝对安全

---

### 高并发解决方案

Java线程池、Ningix负载均衡做集群服务器多抗并发、消息队列解决高并发

但是java不适合做java不适合做多线程，实现不了公平调度的问题，一旦开多了就会阻塞，开到1000个左右，所以用消息队列

如果高并发实在抗不住，可以考虑熔断，熔断无关服务，保障主业务服务器。---服务降级

---

### 订单管理问题（分布式数据一致性问题）

首先确认库存是否满足购买量

然后

消息队列解决分布式一致性问题
- 创建消息队列，需要几个队列创几个，

分布式数据库Mysql自动实现了同步功能

---

### 秒杀---瞬间访问量剧增

1、放消息队列中，先进先出，消费一条，库存减一，没库存的时候直接熔断，记住用户信息放入缓存，防止下次再次请求重新抢；
2、动态扩容，

---

### 数字货币平台

通过代理IP

先进先出，消费者监听队列，

TCP长连接使用WebSocket将数据推送到前端

---

### 版本管理工具
Git和Svn的区别

-  Git对程序源代码进行差异化的版本管理，代码库占极少的空间。易于代码的分支化管理。不支持中文，图形界面支持差，使用难度大。不易推广。

-  Svn对中文支持好，操作简单，使用没有难度，美工人员，产品人员，测试人员，实施人员都可轻松上手。使用界面统一，功能完善，操作方便。

Git怎么样创建分支，怎么使用？

---

### 消息队列

中间件群发的时候，有多个消费者时怎么消费消息
串行，消息队列，会阻塞，就让它阻塞
并行，需要加数据库加锁

---

不断踩坑，解决，涨经验。

订单使用uuid作为唯一字段

混合编程

数字货币有全网价格，从全网API获得数据
，那个交易所一个数据库

Docker做好数据卷，坏了就可以down