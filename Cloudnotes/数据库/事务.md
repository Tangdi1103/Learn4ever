#### JDBC事务
JDBC的autoCommit默认值为true，默认开启自动提交事务，每条执行的SQL语句都是一个单独的事务。

若要开启事务执行多条sql，则将autoCommit设置为false，调用commit方法提交，调用rollback方法回滚

---

#### 数据库事务的特性：ACID——（原子性、一致性、隔离性、持久性）

---

#### 并发事务的问题：
- 脏读：事务A读到了事务B未提交的数据
- 不可重复读：在一个事务里面读取了两次某个数据，读出来的数据不一致（A查B改A查）
- 幻读：在一个事务里面的操作中发现了未被操作的数据（两个事务都有改）

---

#### 隔离级别：
1. READ_UNCOMMITTED读未提交(无法解决脏读、不可重复读、幻读中的任何种)
1. READ_COMMITED读已提交(防止脏读，但是无法解决不可重复读和幻读，锁正在读的行)
1. REPEATABLE_READ重复读取(解决了脏读、不可重复读，但是无法解决幻读，锁所有读取的行)
1. SERLALIZABLE串行化(全部解决，锁表)

###### 注意：读已提交和可重复读通过乐观锁的版本并发机制实现；串行化通过悲观锁方式强制事务串行执行。Mysql默认隔离级别为可重复读，Oracle默认的是读已提交

###### 这里需要注意的是：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 REPEATABLE-READ（可重读） 事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server) 是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读） 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 SERIALIZABLE(可串行化) 隔离级别。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 READ-COMMITTED(读取提交内容) ，但是你要知道的是InnoDB 存储引擎默认使用 REPEAaTABLE-READ（可重读） 并不会有任何性能损失。
   
--- 

#### 锁机制：
1. 悲观锁：例如Synchronized（同步锁）。锁方法或者代码块叫（对象锁）；锁静态方法或者代码块叫（类锁）
1. 乐观锁：可通过版本机制实现

---

#### 分布式事务：
###### InnoDB 存储引擎在 分布式事务 的情况下一般会用到 SERIALIZABLE(可串行化) 隔离级别。

分布式事务和本地事务区别：多节点组成一个事务，可使用RocketMQ解决分布式事务。
分布式的隔离机制可使用zookeeper分布式锁

--- 

#### Spring的事务传播行为
所谓事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。Spring 支持 7 种事务传播行为，默认为REQUIRED
    
##### 支持当前事务的情况：
- TransactionDefinition.PROPAGATION_REQUIRED： 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。
- TransactionDefinition.PROPAGATION_SUPPORTS： 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。
- TransactionDefinition.PROPAGATION_MANDATORY： 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）

##### 不支持当前事务的情况：
- TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建一个新的事务，如果当前存在事务，则把当前事务挂起。
- TransactionDefinition.PROPAGATION_NOT_SUPPORTED： 以非事务方式运行，如果当前存在事务，则把当前事务挂起。
- TransactionDefinition.PROPAGATION_NEVER： 以非事务方式运行，如果当前存在事务，则抛出异常。
##### 其他情况：
- TransactionDefinition.PROPAGATION_NESTED： 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。