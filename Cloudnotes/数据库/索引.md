<font size=4>

#### 索引种类

- 普通索引：仅加速查询

- 唯一索引：加速查询 + 列值唯一（可以有null）

- 主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个

- 组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并，遵循从左到右原则

- 全文索引：对文本的内容进行分词，进行搜索。用于查找关键字，而不是值
 

模糊查询：
- 前通配不走索引
- 后通配走索引

---

#### 创建索引
```
1.添加PRIMARY KEY（主键索引）
ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` ) 

2.添加UNIQUE(唯一索引)
ALTER TABLE `table_name` ADD UNIQUE ( `column` ) 

3.添加INDEX(普通索引)
ALTER TABLE `table_name` ADD INDEX index_name ( `column` )

4.添加FULLTEXT(全文索引)
ALTER TABLE `table_name` ADD FULLTEXT ( `column`) 

5.添加多列索引
ALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` )
```
---

#### 索引失效原因

###### 覆盖索引：就是包含了所有查询字段 (where,select,ordery by,group by 包含的字段) 的索引

```
1.全值匹配我最爱
explain select * from student where name = '张三' and age = 1;

2.最佳左前缀法则，带头大哥不能死，中间兄弟不能少。
explain select * from student where age = 1;

3.不要在索引列上做任何操作
explain select * from student where left(name,1) = '张' and age = 1;


4.范围条件后列上索引失效，查找级别是范围，name上的索引失效。
explain select * from student where age > 1 and name = '王五';


5.尽量使用覆盖索引减少使用select *
explain select * from student where name = 'zhangsan';

Using index
explain select name from student where name = 'zhangsan';

6.使用不等于（！= 或者<>）不能使用索引
explain select * from student where name != '张三';

7.使用 is null 或者 is not null 也不能使用索引
explain select * from student where name is not null;

8.like 已通配符开头（%abc）导致索引失效 （解决方法：使用覆盖索引）
explain select * from student where name like '%张%';

使用覆盖索引
explain select name from student where name like '%张%';

9.少用or，用它来连接索引会失效
explain select * from student where name = '张三' or age = 2;

```

#### explain主要关键字
 <div style="width:110px">关键字</div> | <div style="width:1000px">描述</div> |
| :--- | :--- |
| id | 查询的序号，包含一组数字，表示查询中执行select子句或操作表的顺序。                        相同，执行顺序从上往下；id不同，id值越大，优先级越高，越先执行|
| table | 输出的行所引用的表 |
| type | 1、ref:非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，可能会找多个符合条件的行，属于查找和扫描的混合体2、range:只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引，一般就是where语句中出现了between,in等范围的查询。这种范围扫描索引扫描比全表扫描要好，因为它开始于索引的某一个点，而结束另一个点，不用全表扫描3、index:index 与all区别为index类型只遍历索引树。通常比all快，因为索引文件比数据文件小很多。4、all：遍历全表以找到匹配的行注意:一般保证查询至少达到range级别，最好能达到ref。|
| possible_keys | 指出MySQL能使用哪个索引在该表中找到行 |
| key | 显示MySQL实际决定使用的键(索引)。如果没有选择索引,键是NULL。查询中如果使用覆盖索引，则该索引和查询的select字段重叠。|
| ref | 显示索引的哪一列被使用了，如果有可能是一个常数，哪些列或常量被用于查询索引列上的值 |
| rows | 根据表统计信息以及索引选用情况，大致估算出找到所需的记录所需要读取的行数 |